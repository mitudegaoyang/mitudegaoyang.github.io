---
title: 前端面试经21
abbrlink: 32cd20c6
date: 2021-03-29 10:27:35
tags:
  - 技术积累
  - 前端
  - 面试题
categories:
  - 技术积累
  - 前端
  - 面试题
toc: true
---

![首屏图](https://z3.ax1x.com/2021/03/15/6BreZF.jpg)

<!-- more -->

## 前端面试汇总

### 项目相关

#### 最近的工作经历及项目经验，用到了哪些技术，负责哪些工作

- React
  - hook
    - useState 是一个 React Hook，它允许你向组件添加一个状态变量。
    - useEffect 是一个 React Hook，它允许你将组件与外部系统同步。
      - 第二个可选参数为 [] 时初始化获取数据
      - 第二个可选参数为 一个 或 多个值 时，监听这些值的变化而进行操作
      - 使用 return 的清除机制 [文档传送门](https://zh-hans.legacy.reactjs.org/docs/hooks-effect.html)
    - useRef 是一个 React Hook，它能帮助引用一个不需要渲染的值
      - useRef 用于操作 DOM 元素 `useRef().current.reload()` [文档传送门](https://zhuanlan.zhihu.com/p/609933594)
    - useMemo 是一个 React Hook，它在每次重新渲染的时候能够缓存计算的结果。
- Antd
  - pro-components
  - pro-table
  - pro-card
- single-spa
- charts
  - cloud-charts
  - echarts
- formilyjs
- classNames 一个简单的支持动态多类名的工具库
- eventemitter2 组件间进行事件的监听与传递
- 协同开发
  - 墨刀 在线原型
  - codesign 在线设计稿
  - Yapi 后端代码联调
  - 禅道/JIRA 开发任务拆分管理
  - Jenkins CI/CD
- tailwindcss['teilˌwind] 它是一个 CSS 样式库，为我们提供了构建定制设计而无需使用自定义样式所需的所有构建块

#### 遇到了什么问题及怎么处理的

- 优化问题
  - 数据大屏仿 PPT 横向切换 react-transition-group
    - 使用 location 承接 trend 标记滚动方向
    - 使用 CSSTransition 实现横向滚动特效
    - 横屏切换加载时添加 load 效果，避免白屏
- 兼容问题
  - 九宫格动效低版本浏览器效果差异
- 菜单定制化需求
  - 委员会管理的树形菜单与联动
  - 根节点重复
- formilyjs 复杂场景
  - 数据联动
  - 数据字典获取
    - window.\_\_globalData
    - window.\_\_globalData.currentUser
  - 数据异步获取
    - await window.\_\_api.func()
  - 表单的动态生成

#### 是否封装过组件，封装的过程是什么

> Render Props、Hook、HOC(高阶组件)

Render Props：是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术

```jsx
<Route path="/home" render={() => <div>Home</div>} />
```

Hook: 在 react 16.8 中引入了 Hook 这个概念，使函数式组件也具备 class 组件同样的特性。

```jsx
// useMouse
import React, { useState, useEffect } from 'react'
export default () => {
  const [positionX, setPositionX] = useState(0)
  const [positionY, setPositionY] = useState(0)
  const getMousePosition = (e) => {
    setPositionX(e.clientX)
    setPositionY(e.clientY)
  }
  useEffect(() => {
    document.addEventListener('mousemove', getMousePosition)
    return () => {
      document.removeEventListener('mousemove', getMousePosition)
    };
  });
  return {
    positionX: positionX,
    positionY: positionY
  }
}

// index
import React, {
  useState,
  useEffect
} from 'react'
import useMousePosition from '../hooks/useMouse'
export default () => {
  const mousePosition = useMousePosition()
  return(
    <div>
      <span>鼠标的横坐标{mousePosition.positionX}</span>
      <span>鼠标的纵坐标{mousePosition.positionY}</span>
    </div>
  )
```

HOC（高阶组件）：高阶组件其实就是参数为组件，返回值为新组件的函数。

[React 组件封装技巧（HOC、Render Props、Hook）](https://zhuanlan.zhihu.com/p/111873208)

#### H5 项目做过什么

最近 H5 项目做得比较少，之前做过推广页，平台移动端 H5 版，使用的 [Vux](https://vux.li/) 。

##### 屏幕尺寸适配

[移动端适配 vw+rem 解决方案](https://juejin.cn/post/6844904029898670088)

优点：不需要引入新的 js，一行代码搞定适配问题
缺点：浏览器兼容性差，IE9 以下不支持，但现代浏览器，特别是移动端，基本都支持

##### em 和 rem 的区别

两者都是相对尺寸

em 继承父级元素的字体大小
rem 是相对 HTML 根元素

#### 防抖和节流

函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。

##### 防抖

事件触发过程中不触发，并设置延时。当延时完毕才调取，若延时内再次触发则重置延时。

设置状态或使用 lodash

##### 节流

时间戳和定时器一定时间内只能触发一次

[JS 的防抖与节流](https://juejin.cn/post/6844903618827517965)

#### babel 的作用

Babel 是一个广泛使用的转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。 这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持。

#### webpack 的 loader 和 plugin 的区别

loader： 用于加载待打包的资源
plugin： 用于扩展和增强 webpack 的编译过程

loader： 一般是将某个语法统一处理为统一的语法
plugin： 一般是在打包前或打包后对结果进行再次操作

loader: 让 webpack 能够处理非 js 文件(自身职能理解 js)，然后你就可以利用 webpack 的打包能力，对它们进行处理。例如：

- css-loader
- style-loader
- postcss-loader
- sass-loader
- less-loader

plugins: 从打包优化和压缩，一直到重新定义环境中的变量。例如：

- clean-webpack-plugin (用于清除打包的输出文件夹)
- css-minimizer-webpack-plugin (优化和压缩 CSS)
- uglify-webpack-plugin (优化和压缩 JS)
- eslint-webpack-plugin (使用 eslint 来查找和修复 js 代码中的问题)
- webpack-bundle-analyzer (可视化 webpack 输出的各业务组件和依赖的第三方模块文件的体积，方便做包的优化)
- babel-polyfill (ES6 转换 ES5)

loader：webpack 自身只支持 js 和 json 这两种格式的文件，对于其他文件需要通过 loader 将其转换为 commonJS 规范的文件后，webpack 才能解析到
plugin：是用于在 webpack 打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle 文件优化等操作

[webpack 中 loader 和 plugin 有啥区别](https://zhuanlan.zhihu.com/p/618991058)
[Webpack 常用的 Plugin](https://juejin.cn/post/7158393145258934302)
[webpack 系列之 16 个常用的插件](https://juejin.cn/post/6906089118447435784)

#### 组件库发布至 npm

这个是建立一个私有的 组件库
[npm 私有仓库搭建](https://www.cnblogs.com/zycbloger/p/sinopia.html)

搭建 注册 发布 使用
[npm 私有仓库搭建【verdaccio】](https://www.jianshu.com/p/c61f08b7cb88)

[如何搭建 npm 私有仓库及发布 npm 包](https://www.cnblogs.com/liuming666/p/12470522.html)

#### 路由 hash 和 history 有什么差别

- hash 模式是通过改变锚点(#)来更新页面 URL，并不会触发页面重新加载，我们可以通过 window.onhashchange 监听到 hash 的改变，从而处理路由。
- history 模式是通过调用 window.history 对象上的一系列方法来实现页面的无刷新跳转。

##### hash

hash，原本用来结合锚点控制页面视窗的位置，具有以下特点：

- 可以改变 URL，但不会触发页面重新加载（hash 的改变会记录在 window.hisotry 中）因此并不算是一次 http 请求，所以这种模式不利于 SEO 优化
- 只能修改#后面的部分，因此只能跳转与当前 URL 同文档的 URL
- 只能通过字符串改变 URL
- 通过 window.onhashchange 监听 hash 的改变，借此实现无刷新跳转的功能。

##### history

根据 Mozilla Develop Network 的介绍，调用 history.pushState() 相比于直接修改 hash，存在以下优势

- 新的 URL 可以是与当前 URL 同源的任意 URL，也可以与当前 URL 一样，但是这样会把重复的一次操作记录到栈中
- 通过参数 stateObject 可以添加任意类型的数据到记录中
- 可额外设置 title 属性供后续使用
- 通过 pushState、replaceState 实现无刷新跳转的功能。

###### history 常用方法

- back()：后退到上一个路由；
- forward()：前进到下一个路由，如果有的话；
- go(number)：进入到任意一个路由，正数为前进，负数为后退；
- pushState(obj, title, url)：前进到指定的 URL，不刷新页面；
- replaceState(obj, title, url)：用 url 替换当前的路由，不刷新页面；

前面的 hashchange，你只能改变#后面的 url 片段。而 pushState 设置的新 URL 可以是与当前 URL 同源的任意 URL。
history 模式则会将 URL 修改得就和正常请求后端的 URL 一样,如后端没有配置对应/user/id 的路由处理，则会返回 404 错误。

#### 跨域如何处理

1. 通过 jsonp 跨域
2. 跨域资源共享（CORS）
3. nginx 代理跨域
4. document.domain + iframe 跨域
5. location.hash + iframe
6. window.name + iframe 跨域
7. postMessage 跨域
8. nodejs 中间件代理跨域
9. WebSocket 协议跨域

[前端常见跨域解决方案](https://segmentfault.com/a/1190000011145364)

#### 除了 dayjs 日期库还有用过其他日期库么

moment.js 和 dayjs 的差别

- 库的大小 Moment.js 是一个比较大的库，大小约为 70KB，而 Day.js 是一个非常轻量级的库，大小只有 2KB。如果项目对体积有比较高的要求，使用 Day.js 可能更加适合。
- 库的功能 Moment.js 的 API 相对来说更加全面，提供了更多的功能和选项。Day.js 的 API 则更加简洁，只提供了常用的日期和时间处理方法。

[moment.js 与 day.js 日期库在项目中应用时，该如何选择](https://juejin.cn/post/6922398807472750605)

#### git 提交的时候习惯用命令还是图形化管理工具

##### sourseTree 的校验如何实现的

##### git 插件如何提交

#### eslint 是否了解

指定规范

在项目中使用 Prettier[p'rɪtɪər] 进行自动代码格式化

[Eslint 超简单入门教程](https://www.jianshu.com/p/ad1e46faaea2)

#### 小程序是否接触过

做了一版电子简历的小程序版，使用的是 [ColorUI](https://docs.xzeu.com/)

##### 小程序如何获取 token

1. 微信小程序通过访问 wx.login 获得一个 code，返回给后台
2. 后台拿着这个 code，调用微信的授权接口，获取到 openid 和 session_key 等信息，openid 是用户唯一的
3. 后台拿着 openid 去数据库中检查，该用户是否是第一次登陆
   1. 如果是第一次登陆，那么就新建一个用户--UserAcount；如果不是第一次登陆，就修改该用户的最后登录时间
   2. 不管是不是第一次登录，都有了一个用户
4. 然后根据用户的 openid 和 session_key 利用 JWT(JSON Web Token) 生成 token，下发给微信小程序，小程序端存储 token 并作为请求的凭证

[微信小程序 token 怎么获取](https://juejin.cn/s/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Ftoken%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96)

#### 混合开发用过什么 与原生交互如蓝牙图片等

### 浏览器相关

#### cookie SessionStorage LocalStorage 的差别

相同点：

- 都是存储数据，存储在 web 端，并且都是同源

不同点：

1. cookie 只有 4K 小 并且每一次请求都会带上 cookie 体验不好，浪费带宽
2. session 和 local 直接存储在本地，请求不会携带，并且容量比 cookie 要大的多(sessionStorage 约 5M、localStorage 约 20M)
3. session 是临时会话，当窗口被关闭的时候就清除掉 ，而 local 永久存在，cookie 有过期时间
4. cookie 和 local 都可以支持多窗口共享，而 session 不支持多窗口共享 但是都支持 a 链接跳转的新窗口

cookie 数量和长度都有限制，Web Storage 解决了这样的限制，且 localStorage 做到了永久储存。
但是 Cookie 也是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，
而 Web Storage 仅仅是为了在本地“存储”数据而生。

web 存储的特点

1. 设置、读取方便
2. 容量较大，sessionStorage 约 5M、localStorage 约 20M
3. 只能存储字符串，可以将对象 JSON.stringify() 编码后存储

sessionStorage

1. 生命周期为关闭当前页面窗口
2. 不能多窗口下数据可以共享 （同源策略，百度家的 local 阿里他们家是拿不到）
3. 补充：通过跳转可以 运用场景： 页面跳转的时候可以通过 session 实现数据共享 在一些单页面（spa）的运用中，进行页面传值的时候比较有用

localStorage

1. 永久生效，除非手动删除或用代码删除
2. 可以多窗口共享（同源策略）
3. 运用场景：一些不涉及到安全的一些数据（不要太过庞大）都可以存储到本地

[cookie、sessionStorage、localStorage 详解及应用场景](https://segmentfault.com/a/1190000010400892)

##### AB 相同页面 LocalStorage 是否相互影响

A 页面改变 LocalStorageB 页面如何监听到

- 同一浏览器打开了两个同源页面
- 其中一个网页修改了 localStorage
- 另一网页注册了 storage 事件

[监听 localStorage 变化](https://www.jianshu.com/p/519a1b42d659)

#### H5 缓存

- 离线浏览 用户可在应用离线时使用它们
- 速度 已缓存资源加载得更快
- 减少服务器负载 浏览器将只从服务器下载更新过或更改过的资源。

##### 前端页面缓存问题解决方案

> 前端页面缓存问题是指页面的静态资源（如图片、JS 和 CSS 文件）在浏览器中被缓存后，导致页面不能正确地更新或者加载最新的内容。
> 为了解决这个问题，我们可以采用一些缓存控制策略来解决。

1. 使用 HTTP 缓存头控制缓存: 可以使用 HTTP 头中的 "Cache-Control", "Expires" 或 "Last-Modified" 来控制浏览器缓存。
2. 添加时间戳或版本号: 可以在静态资源的 URL 中添加时间戳或版本号，以便浏览器识别新的资源。
3. 使用 service worker: 可以使用 Service Worker 来缓存页面资源，并在需要时更新缓存。
4. 编码技巧: 可以使用构建工具来自动生成带有哈希值的文件名以及所有引用其的文件。
5. 使用 CDN: 可以使用 CDN 来加速页面资源的加载，同时避免浏览器缓存过期的问题。
6. 强制刷新: 使用 Ctrl+F5 或者在开发工具中清除缓存，强制刷新页面。
7. 使用 manifest: 通过配置 manifest 文件，告诉浏览器该网站需要被离线缓存.

##### H5 更新部署后，浏览器访问时空白页面问题

> 当 H5 页面更新部署到 Nginx 服务器后，浏览器访问时可能出现空白页面，
> 这是因为浏览器使用了缓存，导致页面加载的不是最新版本。解决方法可能有以下几种:

1. 使用版本号或时间戳: 在每次部署新版本时，更新版本号或时间戳，使浏览器能识别新版本并加载
2. 禁用浏览器缓存: 通过在 Nginx 的配置文件中设置 HTTP 头来禁用浏览器缓存
3. 使用 service worker:使用 service worker 缓存页面资源，在需要时更新缓存
4. 清除浏览器缓存: 手动清除浏览器缓存，或者在浏览器中清除整站缓存
5. 强制刷新: 使用 Ctrl+F5 或者在开发工具中清除缓存，强制刷新页面
6. cache-busting :使用文件名哈希值，或者添加查询参数等方式来绕过缓存，强制浏览器加载最新版本
7. 利用更高层面的方式更新页面, 例如使用 PWA(progressive web app) 或者 AppShell 模型来更新页面
8. 配置跨域: 因为跨域可能导致缓存机制失效, 所以需要保证 Nginx 服务器对跨域请求有正确的配置

[移动端 H5 页面缓存问题](https://www.cnblogs.com/yuzhihui/p/17044257.html)
[H5 缓存机制浅析 - 移动端 Web 加载性能优化](https://segmentfault.com/a/1190000004132566)

#### 资源缓存有哪些类型

HTML
JavaScript
CSS、SCSS
图片
SVG
视频、音频和字幕
字体文件

#### 为什么会出现缓存 200 和 304 是怎么发生的

请求 200 还是请求 304 是根据什么区分的

首次请求：200
缓存有效期内请求：200(from cache)——再次请求文件未超时不发送请求
缓存过期后请求：304（Not Modified)——文件缓存超时，发送请求到服务器，并携带本地缓存的文件信息，服务器对比信息(最后修改时间)，可继续使用时，返回 304 表示可据需使用

[HTTP 304 与 200 区别](https://blog.csdn.net/apple_osp/article/details/106717505)

#### http 请求状态码有哪些及含义

- 100: 信息响应
- 200: 成功响应
- 300: 重定向
  - 304: Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
- 400: 客户端响应
  - 401: Unauthorized 响应， 应该用来表示缺失或错误的认证；
  - 403: Forbidden 响应，应该在这之后用，当用户被认证后，但用户没有被授权在特定资源上执行操作。
- 500: 服务端响应
  - 502: 此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。
  - 504: 当服务器作为网关，不能及时得到响应时返回此错误代码。

[状态码决策图](https://www.loggly.com/wp-content/uploads/2015/06/http-decision-diagram.png)

[HTTP 状态码决策图–信息图](https://www.loggly.com/blog/http-status-code-diagram/)

#### http2.0 和 http1.x 的区别

- 协议解析格式不同：http1 的解析是基于文本协议的各式解析，而 http2.0 的协议解析是二进制格式，更加的强大
- 多路复用(Mutiplexing)：一个连接上可以有多个 request，且可以随机的混在一起，每个不同的 request 都有对应的 id，服务端可以通过 request_id 来辨别，大大加快了传输速率
- header 压缩： http1.x 中的 header 需要携带大量信息，而且每次都要重复发送。http2.0 使用 encode 来减少传输的 header 大小，而且客户端和服务端可以各自缓存(cache)一份 header filed 表，避免了 header 的重复传输，还可以减少传输的大小
- 服务端推送(server push)： 可以通过解析 html 中的依赖，智能的返回所需的其他文件(css 或者 js 等)，而不用再发起一次请求

### Vue 相关

#### 如何声明一个全局变量

##### 使用 Vue.prototype

通过在 `vue` 的原型上定义属性，可以在所有组件中访问该属性。例如，我们可以在 `main.js` 文件中添加以下代码:

```js
Vue.prototype.$globalVar = 'Hello World';
```

然后，在任何组件中，我们都可以通过 `this.$globalVar` 来访问该全局变量

```vue
<template>
  <div>
    {{ this.$globalvar }}
  </div>
</template>
```

##### 使用 Vue.mixin

通过混入( `mixin` )的方式，可以将一些公共的属性或方法混入到所有组件中。例如，我们可以在 `main.js` 文件中添加以下代码

```js
Vue.mixin({
  data() {
    return {
      globalVar: 'Hello World!'
    };
  }
});
```

然后，在任何组件中，我们都可以通过 `this.globalVar` 来访问该全局变量

```vue
<template>
  <div>
    {{ this.globalvar }}
  </div>
</template>
```

[vue 设置全局变量：让你的数据无处不在！](https://blog.csdn.net/Shids_/article/details/131418080)

#### 深度选择器 /deep/

- vue 组件的 scoped 属性的作用
- 在 style 标签上添加 scoped 属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；
- 但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；

#### #$route 和 $router 的区别

this.$route: 当前激活的路由的信息对象。每个对象都是局部的，可以获取当前 URL 解析得到的信息，
还有 URL 匹配到的路由记录，包含当前路由的 path,name,params,query 等属性。

this.$router: 全局的 router 实例。通过 vue 根实例中注入 router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。
其中包含了很多属性和对象(比如 history 对象)，任何页面也都可以调用其 push(), replace(), go() 等方法。

可以将 $router 理解为一个容器去管理了一组 $route，而 $route 是进行了当前 URL 和组件的映射

[vue 中 $router 和 $route 的区别](https://blog.csdn.net/qinqinzqq/article/details/126283389)

#### params 和 query 的区别?如何获取传递的参数

url 地址显示：query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，
说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
注意点：query 刷新不会丢失 query 里面的数据 params 刷新会丢失 params 里面的数据。

this.$route.query.name和this.$route.params.name

#### vue-router 的有哪两种模式？ history 模式的问题是是什么？

- hash 模式：即地址栏 URL 中的 # 符号；
- history 模式：window.history 对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）
- hash 模式是通过改变锚点(#)来更新页面 URL，并不会触发页面重新加载，我们可以通过 window.onhashchange 监听到 hash 的改变，从而处理路由。
- history 模式是通过调用 window.history 对象上的一系列方法来实现页面的无刷新跳转。

### React 相关

#### 如何搭建 react 项目

- creat-react-app
- 在 github 搜索比较成熟的库，基于其进行修改
- [从零搭建](https://juejin.cn/post/7134314981515853831)

#### 简述 react 脚手架的原理

```json
// 终端样式库 * 修改命令行终端文字颜色 高亮提示 *
"chalk": "^4.1.0",
// 命令行交互 * cli init *
"commander": "^8.3.0",
// 从 git 拉模板
"download-git-repo": "^3.0.2",
"figlet": "^1.5.2",
// fs 操作扩展
"fs-extra": "^9.1.0",
// 命令行交互 * 问题选项 选择 A or B 模板 *
"inquirer": "^8.2.0",
"lodash": "^4.17.21",
// 日志输出
"log-symbols": "^5.0.0",
// 加载效果，图标
"ora": "5",
"os": "^0.1.2",
// 文件路径
"path": "^0.12.7",
"shelljs": "^0.8.4",
// 检验 npm 名字取得是否正确
"validate-npm-package-name": "^3.0.0"
```

- 接收操作命令 例如 init 别名 i
- 接收配置信息 例如 作者 邮箱 描述 git 地址
- 获取当前路径
- 设置目标路径 当前路径/项目名称
- 获取可选模板 从模板 json 中获取
- 校验当前路径是否存在重名文件夹 如果存在则抛出错误
- 拉取模板
- 编辑 packageJson
  - 在模板 package 的基础上添加名称等信息 并格式化文件
- 若配置信息存在 git 地址则上传到 git 仓库
- 执行 npm i
- 执行 eslint 修复
- 输出成功信息提示

[制作你自己的 cli 脚手架](https://www.bilibili.com/video/BV1Bk4y1y7tR)

#### react Hooks 与 React 生命周期的关系

| 生命周期                 | Hooks                     |
| ------------------------ | ------------------------- |
| constructor              | useState                  |
| getDerivedStateFromProps | useState 里面 update 函数 |
| shouldComponentUpdate    | useMemo                   |
| render                   | 函数本身                  |
| componentDidMount        | useEffect                 |
| componentDidUpdate       | useEffect                 |
| componentWillUnmount     | useEffect 里面返回的函数  |
| componentDidCatch        | 无                        |
| getDerivedStateFromError | 无                        |

[react Hooks 与 React 生命周期的关系](https://zhuanlan.zhihu.com/p/481678531)

#### React 生命周期有哪些

![life-cycle](https://pic1.zhimg.com/80/v2-98631ecaf0c91f6014ab06bbd25dcb8c_1440w.webp)

最新的生命周期 参考上文 Hooks 生命周期对比

[深入详解 React 生命周期](https://juejin.cn/post/6914112105964634119)

[~~旧的生命周期~~](https://z3.ax1x.com/2021/03/29/cP3j8P.png)

生命周期的方法有：

- componentWillMount 在渲染前调用,在客户端也在服务端。
- componentDidMount 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode()来进行访问。 如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout, setInterval 或者发送 AJAX 请求等操作(防止异步操作阻塞 UI)。
- componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用。
- shouldComponentUpdate 返回一个布尔值。在组件接收到新的 props 或者 state 时被调用。在初始化时或者使用 forceUpdate 时不被调用。可以在你确认不需要更新组件时使用。
- componentWillUpdate 在组件接收到新的 props 或者 state 但还没有 render 时被调用。在初始化时不会被调用。
- componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。
- componentWillUnmount 在组件从 DOM 中移除之前立刻被调用。

即将弃用：

- componentWillMount
- componentWillReceiveProps
- componentWillUpdate

新增：

- getDerivedStateFromProps
- getSnapshotBeforeUpdate

[React 的生命周期变化](https://juejin.cn/post/6844904005152276487)

#### Hook

useState 扁平化存储数据
useEffect 初始化时、监听某个或某几个值变化、监听卸载

- 优点：
  - 更容易复用代码
  - 代码量更少
- 缺点：
  - 响应式的 useEffect
  - hooks 不擅长异步的代码
  - custom hooks 有时严重依赖参数的不可变性
- 解决方案：
  - 不要在 useEffect 里面写太多的依赖项，划分这些依赖项成多个单一功能的 useEffect。其实这点是遵循了软件设计的“单一职责模式”。
  - 如果你碰到状态不同步的问题，可以考虑下手动传递参数到函数。
  - 拆分组件，细化组件的粒度。复杂业务场景中使用 hooks，应尽可能地细分组件，使得组件的功能尽可能单一，这样的 hooks 组件更好维护。

[谈谈 react hooks 的优缺点](https://zhuanlan.zhihu.com/p/88593858)

#### react 渲染虚拟 dom 的过程

[深入了解 React 中的虚拟 DOM](https://juejin.cn/post/7157592289487880199)

#### react 列表的 keys 的作用是什么

Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。

一般使用 id，如果没有使用 index。

不推荐使用 index，在可调整排序的列表中性能较差。

#### react 和 vue 的差别有哪些

相同点：

- 都使用 Virtural DOM
- 都使用组件化思想，流程基本一致
- 都是响应式，推崇单向数据流
- 都有成熟的社区，都支持服务端渲染

不同点：

- 理念不同
  - Vue 推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集）
  - React 推崇函数式编程（纯组件），数据不可变以及单向数据流
- 格式不同
  - Vue 推崇 template（简单易懂，从传统前端转过来易于理解）、单文件 vue
  - React 推崇 JSX、all in js、HOC

[Vue 和 React 区别](https://juejin.cn/post/6844904158093377549)

#### react 和 vue 的优缺点

React.js 的优点：灵活性和响应性、虚拟 DOM、丰富的 JavaScript 库、可扩展性、不断发展、Web 或移动平台

- 灵活性和响应性：它提供最大的灵活性和响应能力。
- 虚拟 DOM：由于它基于文档对象模型，因此它允许浏览器友好地以 HTML，XHTML 或 XML 格式排列文档。
- 丰富的 JavaScript 库：来自世界各地的贡献者正在努力添加更多功能。
- 可扩展性：由于其灵活的结构和可扩展性，React 已被证明对大型应用程序更好。
- 不断发展： React 得到了 Facebook 专业开发人员的支持，他们不断寻找改进方法。
- Web 或移动平台： React 提供 React Native 平台，可通过相同的 React 组件模型为 iOS 和 Android 开发本机呈现的应用程序。无论是 Web 还是本机移动开发，React 都是大多数用户界面设计平台的理想选择。

React.js 的缺点：陡峭的学习曲线

- 陡峭的学习曲线：由于复杂的设置过程，属性，功能和结构，它需要深入的知识来构建应用程序。

现在，让我们转到 Vue.js 并谈谈它的优点和缺点：
与 React 相比，Vue.js 的下载量更少，并且主要用于构建有吸引力的单页面应用程序和 Web 应用程序。但是，Vue.js 具有适应性强的体系结构，使其成为广泛使用的框架之一，具有最新的库和包。

使用 Vue.Js 的优点：易于使用、更顺畅的集成、更好的性能，更小的尺寸、精心编写的文档、适应性

- 易于使用： Vue.js 包含基于 HTML 的标准模板，可以更轻松地使用和修改现有应用程序。
- 更顺畅的集成：无论是单页应用程序还是复杂的 Web 界面，Vue.js 都可以更平滑地集成更小的部件，而不会对整个系统产生任何影响。
- 更好的性能，更小的尺寸：它占用更少的空间，并且往往比其他框架提供更好的性能。
- 精心编写的文档：通过详细的文档提供简单的学习曲线，无需额外的知识; HTML 和 JavaScript 将完成工作。
- 适应性：整体合理的设计和架构使其成为一种流行的 JavaScript 框架。它提供无障碍的迁移，简单有效的结构和可重用的模板。

使用 Vue.js 的缺点：市场份额小。世界范围内的外企有刻意回避使用的情况。

- 与 Angular 和 React 相比，Vue.js 框架的市场份额仍然很小。它正在快速流行，但与此同时，在使用 Vue.js 时，可能会出现大规模应用程序开发方面的问题。
  好吧，考虑到其现代功能，速度和灵活性，Vue.js 有可能实现 Web 应用程序开发的里程碑。

> [Vue 和 React 的区别](https://juejin.cn/post/7273032322546466872)

### JS 相关

#### 数组的常见方法

##### 总览

- [添加/删除元素](https://zh.javascript.info/array-methods#tian-jia-yi-chu-shu-zu-yuan-su)：
  - push(...items) —— 向尾端添加元素，
  - pop() —— 从尾端提取一个元素，
  - shift() —— 从首端提取一个元素，
  - unshift(...items) —— 向首端添加元素，
  - splice(pos, deleteCount, ...items) —— 从 pos 开始删除 deleteCount 个元素，并插入 items。
  - slice(start, end) —— 创建一个新数组，将从索引 start 到索引 end（但不包括 end）的元素复制进去。
  - concat(...items) —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 items。如果 items 中的任意一项是一个数组，那么就取其元素。
- [搜索元素](https://zh.javascript.info/array-methods#zai-shu-zu-zhong-sou-suo)：
  - indexOf/lastIndexOf(item, pos) —— 从索引 pos 开始搜索 item，搜索到则返回该项的索引，否则返回 -1。
  - includes(value) —— 如果数组有 value，则返回 true，否则返回 false。
  - find/filter(func) —— 通过 func 过滤元素，返回使 func 返回 true 的第一个值/所有值。
  - findIndex 和 find 类似，但返回索引而不是值。
- [遍历元素](https://zh.javascript.info/array-methods#bian-li-foreach)：
  - forEach(func) —— 对每个元素都调用 func，不返回任何内容。
- [转换数组](https://zh.javascript.info/array-methods#zhuan-huan-shu-zu)：
  - map(func) —— 根据对每个元素调用 func 的结果创建一个新数组。
  - sort(func) —— 对数组进行原位（in-place）排序，然后返回它。
  - reverse() —— 原位（in-place）反转数组，然后返回它。
  - split/join —— 将字符串转换为数组并返回/将数组拼接为字符串返回。
  - reduce/reduceRight(func, initial) —— 通过对每个元素调用 func 计算数组上的单个值，并在调用之间传递中间结果。
- [其他](https://zh.javascript.info/array-methods#arrayisarray)：
  - Array.isArray(value) 检查 value 是否是一个数组，如果是则返回 true，否则返回 false。

##### 添加/删除元素

- arr.push(...items) 从尾端添加元素，
- arr.pop() 从尾端提取元素，
- arr.shift() 从首端提取元素，
- arr.unshift(...items) 从首端添加元素。

###### splice

> `arr.splice(start[, deleteCount, elem1, ..., elemN])`

```js
let arr = ['I', 'study', 'JavaScript'];
arr.splice(1, 1); // 从索引 1 开始删除 1 个元素
alert(arr); // ["I", "JavaScript"]
```

允许负向索引

```js
let arr = [1, 2, 5];
// 从索引 -1（尾端前一位）
// 删除 0 个元素，
// 然后插入 3 和 4
arr.splice(-1, 0, 3, 4);
alert(arr); // 1,2,3,4,5
```

###### slice

> `arr.slice([start], [end])`

```js
let arr = ['t', 'e', 's', 't'];
alert(arr.slice(1, 3)); // e,s（复制从位置 1 到位置 3 的元素）
alert(arr.slice(-2)); // s,t（复制从位置 -2 到尾端的元素）
```

###### concat

> `arr.concat(arg1, arg2...)`

```js
let arr = [1, 2];
// 从 arr 和 [3,4] 创建一个新数组
alert(arr.concat([3, 4])); // 1,2,3,4
// 从 arr、[3,4] 和 [5,6] 创建一个新数组
alert(arr.concat([3, 4], [5, 6])); // 1,2,3,4,5,6
// 从 arr、[3,4]、5 和 6 创建一个新数组
alert(arr.concat([3, 4], 5, 6)); // 1,2,3,4,5,6
```

##### 搜索元素

###### indexOf/lastIndexOf 和 includes

> arr.indexOf(item, from) —— 从索引 from 开始搜索 item，如果找到则返回索引，否则返回 -1。
> arr.includes(item, from) —— 从索引 from 开始搜索 item，如果找到则返回 true（译注：如果没找到，则返回 false）。

```js
let arr = [1, 0, false];
alert(arr.indexOf(0)); // 1
alert(arr.indexOf(false)); // 2
alert(arr.indexOf(null)); // -1
alert(arr.includes(1)); // true
```

###### find 和 findIndex/findLastIndex

```js
let result = arr.find(function (item, index, array) {
  // 如果返回 true，则返回 item 并停止迭代
  // 对于假值（falsy）的情况，则返回 undefined
});
```

```js
let users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Pete' },
  { id: 3, name: 'Mary' }
];
let user = users.find((item) => item.id == 1);
alert(user.name); // John
```

###### filter

```js
let results = arr.filter(function (item, index, array) {
  // 如果 true item 被 push 到 results，迭代继续
  // 如果什么都没找到，则返回空数组
});
```

```js
let users = [
  { id: 1, name: 'John' },
  { id: 2, name: 'Pete' },
  { id: 3, name: 'Mary' }
];
// 返回前两个用户的数组
let someUsers = users.filter((item) => item.id < 3);
alert(someUsers.length); // 2
```

##### 转换数组

###### map

```js
let result = arr.map(function (item, index, array) {
  // 返回新值而不是当前元素
});
```

```js
let lengths = ['Bilbo', 'Gandalf', 'Nazgul'].map((item) => item.length);
alert(lengths); // 5,7,6
```

###### split 和 join

```js
let names = 'Bilbo, Gandalf, Nazgul';
let arr = names.split(', ');
for (let name of arr) {
  alert(`A message to ${name}.`); // A message to Bilbo（和其他名字）
}
```

```js
let arr = ['Bilbo', 'Gandalf', 'Nazgul'];
let str = arr.join(';'); // 使用分号 ; 将数组粘合成字符串
alert(str); // Bilbo;Gandalf;Nazgul
```

[数组方法](https://zh.javascript.info/array-methods)

#### 检测变量的类型并区分数组和对象

| 值               | 类型        |
| ---------------- | ----------- |
| typeof 1         | "number"    |
| typeof NaN       | "number"    |
| typeof "1"       | "string"    |
| typeof true      | "boolean"   |
| typeof undefined | "undefined" |
| typeof null      | "object"    |
| typeof []        | "object"    |
| typeof {}        | "object"    |

- 如果返回 number，判断是否是 NAN，isNaN(a) ，
- 首先使用 typeof 判断，如果返回 object，判断是否为 null
- 判断数组 or 对象
  - 最后使用 toString 如果是"[object Object]”是对象，否则是数组。
  - 最后使用 `[] instanceof Array` `{} instanceof Array`如果是 false 是对象，否则是数组。

[javascript 判断数据类型的几种方法](https://segmentfault.com/a/1190000018160547)

#### 对比对象 A、B 是否相等()

[JavaScript 中，如何判断两个对象是否相等？](https://juejin.cn/post/6844903802298974221)

- 判断 A===B 返回 true
- 判断 A 和 B 长度是否相等
  - 如果不等返回 false
- 遍历对比

##### js 获取对象长度

对象无法直接获取 length，可以使用原生的 Object.keys 获取

```js
var objA = { name: 'Tom', sex: 'male', age: '18' };
var objB = { name: 'Tom', sex: 'male', age: '18' };
var arr = Object.keys(objA);
console.log(arr); // ['name','sex','age']
console.log(arr.length); // 3

// 伪代码
arr.forEach((item) => {
  objA[item] === objB[item];
});
```

#### 多维转一维数组

```js
var arr = [1, 2, [3, 4, [5], 6], 7];
```

- 递归
- toString 正则处理
- Array​.prototype​.flat(Infinity)
- 扩展运算符

递归

> 递归的遍历每一项，若为数组则继续遍历，否则 concat

```js
let arr = [
  [1, 2, [3, 4], 5],
  [6, 7, 8],
  [[9, 10], 11]
];
function flat(arr) {
  let result = [];
  arr.map((item) => {
    if (Array.isArray(item)) {
      result = result.concat(flat(item));
    } else {
      result.push(item);
    }
  });
  return result;
}
console.log(flat(arr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

扩展运算符

> ... 用于取出参数对象的所有可遍历属性，拷贝到当前对象中

```js
let arr = [
  [1, 2, [3, 4], 5],
  [6, 7, 8],
  [[9, 10], 11]
];
function flat(arr) {
  while (arr.some((item) => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
}
console.log(flat(arr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

[扁平化数组的几种方法](https://blog.csdn.net/qq_38128179/article/details/89950590)

#### 变量提升函数提升

##### 变量提升

```js
console.log(a); // undefined
var a = 'a';
var foo = () => {
  console.log(a); // undefined
  var a = 'a1';
};
foo();
```

变量声明的提升是以变量所处的第一层词法作用域为“单位”的，即全局作用域中声明的变量会提升至全局最顶层，函数内声明的变量只会提升至该函数作用域最顶层。那么开始的一段代码经过预编译则变为：

```js
var a;
console.log(a); // undefined
a = 'a';
var foo = () => {
  var a; // 全局变量会被局部作用域中的同名变量覆盖
  console.log(a); // undefined
  a = 'a1';
};
foo();
```

ES6 新增了 let 和 const 关键字，使得 js 也有了“块”级作用域，而且使用 let 和 const 声明的变量和函数是不存在提升现象的，比较有利于我们养成良好的编程习惯。

##### 函数提升

有了上面变量提升的说明，函数提升理解起来就比较容易了，但较之变量提升，函数的提升还是有区别的。举例说明：

```js
console.log(foo1); // [Function: foo1]
foo1(); // fool
console.log(foo2); // undefined
foo2(); // TypeError: foo2 is not a function
function foo1() {
  console.log('foo1');
}
var foo2 = function () {
  console.log('foo2');
};
```

即函数提升只会提升函数声明，而不会提升函数表达式。

[js 中的变量提升和函数提升](https://blog.csdn.net/kontar123/article/details/83508740)

#### 前端模块化的规范

CommonJS： 在 NodeJS 中实现。主要方法是 exports 和 require
AMD：提前执行依赖-尽早执行 requireJs
CMD：按需执行依赖-懒执行 seaJs
ES6: import 和 export

[前端模块化的四种规范](https://www.jianshu.com/p/c38e19cda77c)

#### ES6 有哪些新特性

1. 不一样的变量声明：const 和 let
2. 模板字符串 \`用户名：${name}\`
3. 箭头函数（Arrow Functions）`let func = () => {}`
4. 函数的参数默认值 `let func = (msg = 'Hello') => { console.log(msg) }`
5. Spread(拓展运算符) / Rest(剩余运算符) 操作符 `...`
6. 对象和数组解构 `let { title, name } = object`
7. for...of 和 for...in
8. 对象超类
9. ES6 中的类
10. 二进制和八进制字面量

[ES6 中常用的 10 个新特性讲解](https://juejin.cn/post/6844903618810757128)

##### 箭头函数能作为构造函数吗

- 从上面的运行结果也可以看到箭头函数与构造函数相比，缺少了很多东西，比如：caller，arguments，prototype，但同时也可以看到，箭头函数是有**proto**属性的，所以箭头函数本身是存在原型链的，他也是有自己的构造函数的，但是原型链到箭头函数这一环就停止了，因为它自己没有 prototype 属性，没法让他的实例的**proto**属性指向，所以箭头函数也就无法作为构造函数。
- 同时我们可以看到，由于箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数，不能绑定 this，所以 call()和 apply()的第一个参数会被忽略。

[箭头函数为什么不能作为构造函数？](https://blog.csdn.net/weixin_42798473/article/details/105319353)

#### 原型、原型链是什么

##### 原型是什么

JS 中每个函数都存在有一个原型对象属性 prototype。并且所有函数的默认原型都是 Object 的实例。

##### 原型链是什么

原型链，简单理解就是原型组成的链，对象的**proto**是它的原型，而原型也是一个对象，也有**proto**属性，
原型的**proto**又是原型的原型，就这样可以一直通过**proto**向上找，这就是原型链。当向上找到 Object 的原型的时候，这条原型链就算到头了。

##### 原型链作用

原型链实现了继承。原型链存在两个问题：

1. 包含引用类型值的原型属性会被所有实例共享。
2. 在创建子类型时，无法向超类型的构造函数中传递参数。

##### 如何检测它的原型链

```js
prototypeObject.isPrototypeOf(object);
```

[JS isPrototypeOf()方法：检测一个对象是否存在于另一个对象的原型链中](https://juejin.cn/post/6868807571084574733)

##### 实例的原型链的上一层指向什么

构造函数的 protoType

#### New 关键词干了什么

1. 创建一个新对象
2. 将新对象的*proto*指向构造函数的 prototype 对象
3. 将构造函数的作用域赋值给新对象 （也就是 this 指向新对象）
4. 执行构造函数中的代码（为这个新对象添加属性）
5. 返回新的对象

```js
var Obj = {};
Obj._proto_ = Person.prototype();
Person.call(Obj);
```

[js 中的 new 关键字做了什么？](https://blog.csdn.net/weixin_34038293/article/details/92886267)

#### 事件监听函数参数有什么

event、function、Boolean

event：监听什么事件
function：触发什么方法
Boolean：是否冒泡

#### Promise

Promise(resolve, reject)和 Promise.all([])

##### promise 代码的输出结果是什么

```js
new Promise((resolve) => {
  resolve('ok');
  throw new Error('err');
})
  .then(console.log)
  .catch(console.error);
```

> 输出结果是什么

(ok)

> 为什么不是 err

[promise 执行顺序总结](https://yuanfentiank789.github.io/2019/11/07/promise%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93/)

##### promise 有哪些状态是如何改变的

promise 有 3 种状 态： pending、fulfilled 或 rejected。
状态改变只能是 pending->fulfilled 或者 pending-> rejected，状态一旦改变则不能再变。

##### promise 的.then 的参数类型是什么

Promise 类型的对象

[Promise.then 函数返回值类型与参数传递](https://blog.csdn.net/weixin_41728198/article/details/103450075)

##### 手动实现 Promise.all

```js
Promise.all2 = function (promises) {
  return new Promise(function (resolve, reject) {
    const len = promises.length;
    let count = 0,
      results = new Array(len);
    for (let i = 0; i < len; i++) {
      Promise.resolve(promises[i]).then(
        (value) => {
          count++;
          results[i] = value;
          if (count === len) {
            return resolve(results);
          }
        },
        (reason) => {
          return reject(reason);
        }
      );
    }
  });
};

let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p1 resolved');
  }, 1000);
});

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('p2 resolved');
  }, 2000);
});

// Promise.all
console.time('cost');
Promise.all2([p1, p2]).then((res) => {
  console.log(res);
  console.timeEnd('cost');
});
```

[理解和使用 Promise.all 和 Promise.race](https://www.jianshu.com/p/7e60fc1be1b2)

#### 使用 promise 实现 sleep()

```js
(async function () {
  /**
   * s 休眠时长， 单位：秒
   */
  function sleep(s) {
    s = s || 0;
    s = parseInt(s) * 1000;
    let now = +new Date();
    let timer = null;
    return new Promise((resolve, reject) => {
      timer = setInterval(() => {
        if (now + s < +new Date()) {
          clearInterval(timer);
          resolve(true);
        }
      }, 10);
    });
  }

  console.log(`start: ${new Date()}`);
  await sleep(3); // 休眠3秒
  console.log(`end  : ${new Date()}`);
})();
```

[JavaScript 通过 Promise 实现 sleep 方法](https://blog.csdn.net/u013137242/article/details/83054750)

#### 常见设计模式

- 创建型模式
  - 工厂模式
  - 单例模式
- 结构型模式
  - 适配器
  - 组合模式
  - 装饰模式
  - 代理模式
- 行为模式
  - 观察者模式
  - 策略模式
  - 模板方法模式

##### 工厂模式

在父类中提供一个创建对象的接口，以允许子类根据具体的需要创建对象。

**应用场景**：

1. 当你在编码过程中，无法预知要使用的对象的确切类别时

**设计原则**：

1. 单一职责（工厂类负责所有对象的创建）
2. 开闭原则（在增加新的类型时，客户端无需修改代码）

##### 单例模式

保证一个类只有一个实例，并提供一个全局的访问方式。

**应用场景**：

1. 当你需要保证一个类只有一个实例时。比如：控制某个共享资源的访问权限。
2. 当你需要提供一个全局访问某个实例的方式，同时又要保护该实例不会被复写时。

##### 策略模式

能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

**应用场景**：

1. 当你有许多仅在执行某些行为时略有不同的相似类时。
2. 当你想要将类的业务逻辑与其算法实现细节隔离开来时。

##### 观察者模式

允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。

**应用场景**：

1. 当一个对象状态的改变需要引起其他对象的改变时

[浅析常用设计模式及应用场景](https://xie.infoq.cn/article/b81e720d57e4d453c5067aaa1)

#### 常见数据结构

- 数组
- 栈
- 队列
- 链表
- 图
- 树
- 前缀树
- 哈希表

### HTML 相关

#### 圣杯布局双飞翼布局

![圣杯布局双飞翼布局](https://z3.ax1x.com/2021/03/29/cP8SKS.jpg)

##### 圣杯布局

- 首先把 left、middle、right 都放出来
- 给它们三个设置上 float: left, 脱离文档流；
- 一定记得给 container 设置上 overflow: hidden; 可以形成 BFC 撑开文档
- left、right 设置上各自的宽度
- middle 设置 width: 100%;

接下来比较重要了：

- 给 left、middle、right 设置 position: relative;
- left 设置 left: -leftWidth, right 设置 right: -rightWidth;
- container 设置 padding: 0, rightWidth, 0, leftWidth;

##### 双飞翼布局

- 首先把 left、middle、right 都放出来, middle 中增加 inner
- 给它们三个设置上 float: left, 脱离文档流；
- 一定记得给 container 设置上 overflow: hidden; 可以形成 BFC 撑开文档
- left、right 设置上各自的宽度
- middle 设置 width: 100%;

接下来与圣杯布局不一样的地方：

- left 设置 margin-left: -100%, right 设置 right: -rightWidth;
- container 设置 padding: 0, rightWidth, 0, leftWidth;

[深入理解圣杯布局和双飞翼布局](https://juejin.cn/post/6844903817104850952)

#### 相邻元素 margin 重叠产生的原因及解决方法

[垂直方向 margin 重叠原因与解决方法](https://my.oschina.net/u/2612473/blog/2221555)

##### 什么是 BFC 为什么会有 BFC 的概念

什么是 BFC：Block Formatting Context，解释为块级格式化上下文

一个 HTML 元素要创建 BFC，则满足下列的任意一个或多个条件即可：

1、float 的值不是 none。（float:left 或者 float:right）
2、position 的值不是 static 或者 relative。（position:absolute 或者 position:fixed）
3、display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex
4、overflow 的值不是 visible（overflow:hidden、overflow:scroll）
5、父元素与正常文件流的子元素（非浮动子元素）自动形成一个 BFC

[什么是 BFC？看这一篇就够了](https://blog.csdn.net/sinat_36422236/article/details/88763187)
[BFC 是什么？](https://zhuanlan.zhihu.com/p/45515245)

BFC 特性/功能

- 父亲管儿子(子元素浮动，父元素不再塌陷)
- 兄弟之间划清界限(兄弟元素其一浮动重叠，另一个元素设置 BFC 便不再重叠)

### CSS 相关

#### div 垂直水平居中

方法 1：绝对定位+margin:auto

```css
div {
  width: 200px;
  height: 200px;
  background: green;

  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  margin: auto;
}
```

方法 2：绝对定位+负 margin

```css
div {
  width: 200px;
  height: 200px;
  background: green;

  position: absolute;
  left: 50%;
  top: 50%;
  margin-left: -100px;
  margin-top: -100px;
}
```

方法 3：绝对定位+transform

```css
div {
  width: 200px;
  height: 200px;
  background: green;

  position: absolute;
  left: 50%; /* 定位父级的50% */
  top: 50%;
  transform: translate(-50%, -50%); /*自己的50% */
}
```

方法 4：flex 布局

```css
.box {
  height: 600px;

  display: flex;
  justify-content: center; //子元素水平居中
  align-items: center; //子元素垂直居中
  /* aa只要三句话就可以实现不定宽高水平垂直居中。 */
}
.box > div {
  background: green;
  width: 200px;
  height: 200px;
}
```

方法 5：table-cell 实现居中

设置
display:table-cell;
text-align:center;
vertical-align: middle;

### 其他

#### 前端项目性能优化

- 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域
- 请求带宽：开启 Gzip，精简 JS，移除重复脚本，图像优化，将 Icon 做成字体
- 缓存利用：使用 CDN，使用外部 JS、CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AJAX 可缓存
- 页面结构：样式表放在顶部，脚本放在底部，尽早刷新文档的输出
- 代码校验：避免 CSS 表达式，避免重定向

#### 输入地址后的过程

1. 域名解析
2. 发起 TCP3 次握手
3. 建立 TCP 链接后发起 http 请求
4. 服务器响应 http 请求，浏览器获得 html 代码
5. 浏览器解析 html 代码，并请求 html 中的资源
6. 浏览器对页面进行渲染并呈现给用户

#### 浏览器渲染过程

1. 解析 HTML 生成 DOM 树。
2. 解析 CSS 生成 CSSOM 规则树。
3. 将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。
4. 遍历渲染树开始布局，计算每个节点的位置大小信息。
5. 将渲染树每个节点绘制到屏幕。

[十分钟读懂浏览器渲染流程](https://juejin.cn/post/6844903565610188807)

#### 浏览器循环机制

调用栈先入后出
消息队列先入先出：异步操作-feath、settimeout
微任务在消息队列前执行 promise
![EventLoop](https://z3.ax1x.com/2021/03/29/c9b9hQ.png)
调用栈先进后出
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bPpj.png)
fetch、事件回调、setTimeout、setInterval 会压入消息队列，消息队列在调用栈清空后执行，先入先出
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bSAS.png)
使用 promise、async await 创建的异步操作会被放置于微任务队列，会在调用栈清空时立即执行，先于消息队列执行
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bptg.png)

[浏览器事件循环机制（event loop）](https://juejin.cn/post/6844903606466904078)
[2 分钟了解 JavaScript Event Loop](https://www.bilibili.com/video/BV1kf4y1U7Ln?from=search&seid=2586724673120864651)

#### 请求的方法有哪些 option 是什么含义

GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE

##### HEAD

HEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。

##### CONNECT

CONNECT 方法是 HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。

##### OPTIONS

OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'\*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

##### TRACE

TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。

[HTTP 请求方法详解](https://itbilu.com/other/relate/EkwKysXIl.html)

#### 网站漏洞的攻击方式和预防

网络安全攻击方式

##### DDoS 攻击

DDoS 是最常见的一种攻击方式，攻击者通过向某一个站点服务器反复发送请求，导致服务器无法承载大量的请求而产生“拒绝服务”，这就导致正常的服务无法进行，影响我们服务器的使用。

##### 获取账号和密码

这类攻击会存在一定的技术性。一般来说，攻击者会利用程序来抓取数据包，获取口令和数据内容，通过侦听程序在来监视网络数据流，进而通过分析获取用户的登录账号和密码。

##### SQL 注入

SQL 注入的攻击手段主要是利用后台的漏洞，通过 URL 将关键 SQL 语句带入程序，在数据库中进行破坏。许多的攻击者会使用 F12 或者 postman 等拼装 ajax 请求，将非法的数字发送给后台，造成程序的报错，并展现在页面上，这样攻击者就会知道后台使用的语言和框架了。

##### 恶意小程序

这类攻击的方式主要存在我们使用的程序上面，它们可以通过入侵修改硬盘上的文件、窃取口令等。

##### 木马植入

这种攻击方式主要是通过向服务器植入木马，开启后面，获取服务器的控制权，恶意破坏服务器文件或盗取服务器数据，这类的危害都是比较大的。

[WEB 应用常见 15 种安全漏洞一览](https://blog.fundebug.com/2019/01/25/11-security-flaws-for-web-application/)

#### 最近有新学习什么技术么

##### flutter1.0 和 2.0 的差别有什么

Flutter2.0 最大的变化是除了之前已经处于 stable 渠道的移动设备支持外，
桌面和 Web 支持也正式宣布进入 stable 渠道.
