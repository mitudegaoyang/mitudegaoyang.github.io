---
title: 前端面试经
abbrlink: 32cd20c6
date: 2021-03-29 10:27:35
tags:
  - 技术积累
  - 前端
  - 面试题
categories:
  - 技术积累
  - 前端
  - 面试题
toc: true
---

![首屏图](https://z3.ax1x.com/2021/03/15/6BreZF.jpg)

<!-- more -->

## 前端面试汇总

### 项目相关

最近的工作经历及项目经验，用到了哪些技术，负责哪些工作。

遇到了什么问题及怎么处理的。

#### 是否封装过组件，封装的过程是什么

#### H5项目做过什么

##### 屏幕尺寸适配

[都2020移动端适配你还用flexible.js吗？vw+rem一行代码搞定](https://juejin.cn/post/6844904029898670088)

优点：不需要引入新的 js，一行代码搞定适配问题
缺点：浏览器兼容性差，IE9 以下不支持，但现代浏览器，特别是移动端，基本都支持3

##### em和rem的区别

两者都是相对尺寸

em继承父级元素的字体大小
rem是相对HTML根元素

#### 防抖和节流

函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。

##### 防抖

事件触发过程中不触发，并设置延时。当延时完毕才调取，若延时内再次触发则重置延时。

设置状态或使用lodash

##### 节流

时间戳和定时器一定时间内只能触发一次

[JS的防抖与节流](https://juejin.cn/post/6844903618827517965)

#### babel的作用

Babel是一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。 这意味着，你可以现在就用ES6 编写程序，而不用担心现有环境是否支持。

#### webpack的loader和plugin的区别

loader一般是将某个语法统一处理为统一的语法
plugin一般是在打包前或打包后对结果进行再次操作

loader:让webpack能够处理非js文件(自身职能理解js)，然后你就可以利用 webpack 的打包能力，对它们进行处理。
例如：css-loader、style-loader、postcss-loader、sass-loader

plugins:从打包优化和压缩，一直到重新定义环境中的变量.
例如：uglify-webpack-plugin、clean-webpack-plugin、babel-polyfill

loader用于加载待打包的资源
plugin 用于扩展 webpack
loader：webpack自身只支持js和json这两种格式的文件，对于其他文件需要通过loader将其转换为commonJS规范的文件后，webpack才能解析到
plugin：是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作

#### 组件库发布至npm

这个是建立一个私有的 组件库
[npm私有仓库搭建](https://www.cnblogs.com/zycbloger/p/sinopia.html)

搭建 注册 发布 使用
[npm私有仓库搭建【verdaccio】](https://www.jianshu.com/p/c61f08b7cb88)

[手把手教你搭建npm私有仓库及发布高质量的npm包](https://my.oschina.net/u/4292771/blog/3306024)

#### 路由hash和history有什么差别

* hash模式是通过改变锚点(#)来更新页面URL，并不会触发页面重新加载，我们可以通过window.onhashchange监听到hash的改变，从而处理路由。
* history模式是通过调用window.history对象上的一系列方法来实现页面的无刷新跳转。

##### hash

hash，原本用来结合锚点控制页面视窗的位置，具有以下特点：

* 可以改变URL，但不会触发页面重新加载（hash的改变会记录在window.hisotry中）因此并不算是一次http请求，所以这种模式不利于SEO优化
* 只能修改#后面的部分，因此只能跳转与当前URL同文档的URL
* 只能通过字符串改变URL
* 通过window.onhashchange监听hash的改变，借此实现无刷新跳转的功能。

##### history

根据 Mozilla Develop Network 的介绍，调用 history.pushState() 相比于直接修改 hash，存在以下优势

* 新的URL可以是与当前URL同源的任意 URL，也可以与当前URL一样，但是这样会把重复的一次操作记录到栈中
* 通过参数stateObject可以添加任意类型的数据到记录中
* 可额外设置title属性供后续使用
* 通过pushState、replaceState实现无刷新跳转的功能。

###### history常用方法

* back()：后退到上一个路由；
* forward()：前进到下一个路由，如果有的话；
* go(number)：进入到任意一个路由，正数为前进，负数为后退；
* pushState(obj, title, url)：前进到指定的 URL，不刷新页面；
* replaceState(obj, title, url)：用 url 替换当前的路由，不刷新页面；

#### 跨域如何处理

1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域

[前端常见跨域解决方案](https://segmentfault.com/a/1190000011145364)

#### 除了dayjs日期库还有用过其他日期库么

moment.js和dayjs的差别

#### git提交的时候习惯用命令还是图形化管理工具

##### sourseTree的校验如何实现的

##### git插件如何提交

#### eslint是否了解

指定规范

[Eslint 超简单入门教程](https://www.jianshu.com/p/ad1e46faaea2)

#### 小程序是否接触过

做了一版小程序

#### 混合开发用过什么 与原生交互如蓝牙图片等

### 浏览器相关

#### cookie SessionStorage LocalStorage的差别

cookie数量和长度都有限制，Web Storage解决了这样的限制，且localStorage做到了永久储存。
但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，
而Web Storage仅仅是为了在本地“存储”数据而生。

[cookie、sessionStorage、localStorage 详解及应用场景](https://segmentfault.com/a/1190000010400892)

##### AB相同页面LocalStorage是否相互影响

A页面改变LocalStorageB页面如何监听到

#### H5缓存

[H5 缓存机制浅析 - 移动端 Web 加载性能优化](https://segmentfault.com/a/1190000004132566)

#### 资源缓存有哪些类型

HTML
JavaScript
CSS、SCSS
图片
SVG
视频、音频和字幕
字体文件

#### 为什么会出现缓存200和304是怎么发生的

请求200还是请求304是根据什么区分的

首次请求：200
缓存有效期内请求：200(from cache)——再次请求文件未超时不发送请求
缓存过期后请求：304（Not Modified)——文件缓存超时，发送请求到服务器，并携带本地缓存的文件信息，服务器对比信息(最后修改时间)，可继续使用时，返回304表示可据需使用

[HTTP 304 与 200 区别](https://blog.csdn.net/apple_osp/article/details/106717505)

#### Http请求状态码有哪些及含义

* 100:信息响应
* 200:成功响应
* 300:重定向
  * 304: Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
* 400:客户端响应
* 500:服务端响应
  * 502:此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。
  * 504:当服务器作为网关，不能及时得到响应时返回此错误代码。

#### http2.0和http1.x的区别

* http1的解析是基于文本协议的各式解析,而http2.0的协议解析是二进制格式,更加的强大
* 多路复用(Mutiplexing) : 一个连接上可以有多个request,且可以随机的混在一起,每个不同的request都有对应的id,服务端可以通过request_id来辨别,大大加快了传输速率
* header压缩: http1.x中的header需要携带大量信息.而且每次都要重复发送.http2.0使用encode来减少传输的header大小.而且客户端和服务端可以各自缓存(cache)一份header filed表,避免了header的重复传输,还可以减少传输的大小.
* 服务端推送(server push): 可以通过解析html中的依赖,智能的返回所需的其他文件(css或者js等),而不用再发起一次请求.

### React相关

#### 如何搭建react项目

creat-react-app

#### 简述react脚手架的原理

#### React生命周期有哪些

![life-cycle](https://z3.ax1x.com/2021/03/29/cP3j8P.png)

生命周期的方法有：

* componentWillMount    在渲染前调用,在客户端也在服务端。
* componentDidMount 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。
* componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。
* shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。可以在你确认不需要更新组件时使用。
* componentWillUpdate   在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。
* componentDidUpdate    在组件完成更新后立即调用。在初始化时不会被调用。
* componentWillUnmount  在组件从 DOM 中移除之前立刻被调用。

#### Hook

useState 扁平化存储数据
useEffect 初始化时、监听某个或某几个值变化、监听卸载

[谈谈react hooks的优缺点](https://zhuanlan.zhihu.com/p/88593858)

#### react渲染虚拟dom的过程

#### react列表的keys的作用是什么

Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。

一般使用id，如果没有使用index。

不推荐使用index，在可调整排序的列表中性能较差。

### JS相关

#### 检测变量的类型并区分数组和对象

|值|类型|
|--|--|
|typeof 1   | "number" |
|typeof NaN | "number" |
|typeof "1" | "string" |
|typeof true | "boolean" |
|typeof undefined | "undefined" |
|typeof null | "object" |
|typeof []   | "object" |
|typeof {}   | "object" |

* 如果返回number，判断是否是NAN，isNaN(a) ，
* 首先使用typeof判断，如果返回object，判断是否为null
* 最后使用toString如果是"[object Object]”是对象，否则是数组。

[javascript 判断数据类型的几种方法](https://segmentfault.com/a/1190000018160547)

#### 对比对象A、B是否相等()

[JavaScript 中，如何判断两个对象是否相等？](https://juejin.cn/post/6844903802298974221)

* 判断A===B 返回true
* 判断A和B长度是否相等
  * 如果不等返回false
* 遍历对比

##### js获取对象长度

对象无法直接获取length，可以使用原生的Object.keys获取

```js
var obj = {'name' : 'Tom', 'sex' : 'male', 'age' : '18'}
var arr = Object.keys(obj);
console.log(arr)    // ['name','sex','age']
console.log(arr.length)    // 3
```

```js
// 伪代码
for(item each A){
    A[item] === B[item]
}
```

#### 多维转一维数组

```js
var arr = [1, 2, [3, 4, [5], 6], 7]
```

* 递归
* toString正则处理
* Array​.prototype​.flat(Infinity)
* 扩展运算符

[扁平化数组的几种方法](https://blog.csdn.net/qq_38128179/article/details/89950590)

#### 变量提升函数提升

#### 前端模块化的规范

CommonJS： 在 NodeJS 中实现。主要方法是 exports 和 require
AMD：提前执行依赖-尽早执行  requireJs
CMD：按需执行依赖-懒执行    seaJs
ES6: import 和 export

#### ES6有哪些新特性

1. 不一样的变量声明：const和let
2. 模板字符串
3. 箭头函数（Arrow Functions）
4. 函数的参数默认值
5. Spread / Rest 操作符
6. 二进制和八进制字面量
7. 对象和数组解构
8. 对象超类
9. for...of 和 for...in
10. ES6中的类

[ES6中常用的10个新特性讲解](https://juejin.cn/post/6844903618810757128)

##### 箭头函数能作为构造函数吗

* 从上面的运行结果也可以看到箭头函数与构造函数相比，缺少了很多东西，比如：caller，arguments，prototype，但同时也可以看到，箭头函数是有__proto__属性的，所以箭头函数本身是存在原型链的，他也是有自己的构造函数的，但是原型链到箭头函数这一环就停止了，因为它自己没有prototype属性，没法让他的实例的__proto__属性指向，所以箭头函数也就无法作为构造函数。
* 同时我们可以看到，由于箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数，不能绑定this，所以call()和apply()的第一个参数会被忽略。

[箭头函数为什么不能作为构造函数？](https://blog.csdn.net/weixin_42798473/article/details/105319353)

#### 原型链是什么

##### 如何检测它的原型链

```js
prototypeObject.isPrototypeOf(object);
```

[JS isPrototypeOf()方法：检测一个对象是否存在于另一个对象的原型链中](http://c.biancheng.net/view/5801.html)

##### 实例的原型链的上一层指向什么

构造函数的protoType

#### New关键词干了什么

#### 事件监听函数参数有什么

event、function、Boolean

event：监听什么事件
function：触发什么方法
Boolean：是否冒泡

#### Promise

Promise(resolve, reject)和Promise.all([])

##### promise代码的输出结果是什么

```js
new Promise(resolve => {
  resolve('ok')
  throw new Error('err')
}).then(console.log).catch(console.error)
```

> 输出结果是什么

(ok)

> 为什么不是err

[promise执行顺序总结](https://yuanfentiank789.github.io/2019/11/07/promise%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93/)

##### promise有哪些状态是如何改变的

promise 有 3 种状 态： pending、fulfilled 或 rejected。
状态改变只能是 pending->fulfilled 或者 pending-> rejected，状态一旦改变则不能再变。

##### promise的.then的参数类型是什么

Promise类型的对象

[Promise.then函数返回值类型与参数传递](https://blog.csdn.net/weixin_41728198/article/details/103450075)

##### 手动实现Promise.all

```js
Promise.all2 = function (promises) {
    return new Promise(function (resolve, reject) {
      const len = promises.length;
      let count = 0,
        results = new Array(len);
      for (let i = 0; i < len; i++) {
        Promise.resolve(promises[i]).then((value) => {
          count++;
          results[i] = value;
          if (count === len) {
            return resolve(results);
          }
        }, (reason) => {
          return reject(reason);
        })
      }
    })
}

let p1 = new Promise((resolve, reject) => {
setTimeout(() => {
    resolve('p1 resolved');
}, 1000)
})

let p2 = new Promise((resolve, reject) => {
setTimeout(() => {
    resolve('p2 resolved');
}, 2000)
})

// Promise.all
console.time('cost');
Promise.all2([p1, p2]).then(res => {
console.log(res);
console.timeEnd('cost');
})
```

[理解和使用Promise.all和Promise.race](https://www.jianshu.com/p/7e60fc1be1b2)

#### 使用promise实现sleep()

```js
(async function(){
    /**
    * s 休眠时长， 单位：秒
    */
    function sleep(s){
        s = s || 0;
        s  = parseInt(s) * 1000;
        let now = +new Date();
        let timer = null;
        return new Promise((resolve, reject)=>{
            timer = setInterval(()=>{
                if( now + s < +new Date()){
                    clearInterval(timer);
                    resolve(true);
                }
            }, 10)
        })

    }


console.log(`start: ${new Date()}`);
await sleep(3); // 休眠3秒
console.log(`end  : ${new Date()}`);
})()
```

[JavaScript通过Promise实现sleep方法](https://blog.csdn.net/u013137242/article/details/83054750)

#### 常见设计模式

* 创建型模式
  * 工厂模式
  * 单例模式
* 结构型模式
  * 适配器
  * 组合模式
  * 装饰模式
  * 代理模式
* 行为模式
  * 观察者模式
  * 策略模式
  * 模板方法模式

##### 工厂模式
  
在父类中提供一个创建对象的接口，以允许子类根据具体的需要创建对象。

**应用场景**：

1、当你在编码过程中，无法预知要使用的对象的确切类别时

**设计原则**：

1、单一职责（工厂类负责所有对象的创建）

2、开闭原则（在增加新的类型时，客户端无需修改代码）

##### 单例模式

保证一个类只有一个实例，并提供一个全局的访问方式。

**应用场景**：

1、当你需要保证一个类只有一个实例时。比如：控制某个共享资源的访问权限。

2、当你需要提供一个全局访问某个实例的方式，同时又要保护该实例不会被复写时。

##### 策略模式

##### 观察者模式

[浅析常用设计模式及应用场景](https://xie.infoq.cn/article/b81e720d57e4d453c5067aaa1)

#### 常见数据结构

* 数组
* 栈
* 队列
* 链表
* 图
* 树
* 前缀树
* 哈希表

### HTML相关

#### 圣杯布局双飞翼布局

![圣杯布局双飞翼布局](https://z3.ax1x.com/2021/03/29/cP8SKS.jpg)

##### 圣杯布局

* 首先把left、middle、right都放出来
* 给它们三个设置上float: left, 脱离文档流；
* 一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档
* left、right设置上各自的宽度
* middle设置width: 100%;

接下来比较重要了：

* 给left、middle、right设置position: relative;
* left设置 left: -leftWidth, right设置 right: -rightWidth;
* container设置padding: 0, rightWidth, 0, leftWidth;

##### 双飞翼布局

* 首先把left、middle、right都放出来, middle中增加inner
* 给它们三个设置上float: left, 脱离文档流；
* 一定记得给container设置上overflow: hidden; 可以形成BFC撑开文档
* left、right设置上各自的宽度
* middle设置width: 100%;

接下来与圣杯布局不一样的地方：

* left设置 margin-left: -100%, right设置 right: -rightWidth;
* container设置padding: 0, rightWidth, 0, leftWidth;

[深入理解圣杯布局和双飞翼布局](https://juejin.cn/post/6844903817104850952)

#### 相邻元素margin重叠产生的原因及解决方法

[垂直方向margin重叠原因与解决方法](https://my.oschina.net/u/2612473/blog/2221555)

##### 什么是BFC为什么会有BFC的概念

什么是BFC：Block Formatting Context，解释为块级格式化上下文

一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：

1、float的值不是none。（float:left 或者float:right）
2、position的值不是static或者relative。（position:absolute或者position:fixed）
3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex
4、overflow的值不是visible（overflow:hidden、overflow:scroll）
5、父元素与正常文件流的子元素（非浮动子元素）自动形成一个BFC

[什么是BFC？看这一篇就够了](https://blog.csdn.net/sinat_36422236/article/details/88763187)
[BFC是什么？](https://zhuanlan.zhihu.com/p/45515245)

BFC 特性/功能

* 父亲管儿子(子元素浮动，父元素不再塌陷)
* 兄弟之间划清界限(兄弟元素其一浮动重叠，另一个元素设置BFC便不再重叠)

### CSS相关

#### iv垂直水平居中

方法1：绝对定位+margin:auto

```css
div{
    width: 200px;
    height: 200px;
    background: green;
    
    position:absolute;
    left:0;
    top: 0;
    bottom: 0;
    right: 0;
    margin: auto;
}
```

方法2：绝对定位+负margin

```css
div{
    width:200px;
    height: 200px;
    background:green;
    
    position: absolute;
    left:50%;
    top:50%;
    margin-left:-100px;
    margin-top:-100px;
}
```

方法3：绝对定位+transform

```css
div{
    width: 200px;
    height: 200px;
    background: green;
    
    position:absolute;
    left:50%;    /* 定位父级的50% */
    top:50%;
    transform: translate(-50%,-50%); /*自己的50% */
}
```

方法4：flex布局

```css
.box{
    height:600px;  
    
    display:flex;
    justify-content:center;  //子元素水平居中
    align-items:center;      //子元素垂直居中
    /* aa只要三句话就可以实现不定宽高水平垂直居中。 */
}
.box>div{
    background: green;
    width: 200px;
    height: 200px;
}
```

方法5：table-cell实现居中

设置
display:table-cell;
text-align:center;
vertical-align: middle;

### 其他

#### 前端项目性能优化

* 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域
* 请求带宽：开启Gzip，精简JS，移除重复脚本，图像优化，将Icon做成字体
* 缓存利用：使用CDN，使用外部JS、CSS，添加Expires头，减少DNS查找，配置ETag，使AJAX可缓存
* 页面结构：样式表放在顶部，脚本放在底部，尽早刷新文档的输出
* 代码校验：避免CSS表达式，避免重定向

#### 输入地址后的过程

1. 域名解析
1. 发起TCP3次握手
1. 建立TCP链接后发起http请求
1. 服务器响应http请求，浏览器获得html代码
1. 浏览器解析html代码，并请求html中的资源
1. 浏览器对页面进行渲染并呈现给用户

#### 浏览器渲染过程

1. 解析HTML生成DOM树。
1. 解析CSS生成CSSOM规则树。
1. 将DOM树与CSSOM规则树合并在一起生成渲染树。
1. 遍历渲染树开始布局，计算每个节点的位置大小信息。
1. 将渲染树每个节点绘制到屏幕。

[十分钟读懂浏览器渲染流程](https://juejin.cn/post/6844903565610188807)

#### 浏览器循环机制

调用栈先入后出
消息队列先入先出：异步操作-feath、settimeout
微任务在消息队列前执行 promise
![EventLoop](https://z3.ax1x.com/2021/03/29/c9b9hQ.png)
调用栈先进后出
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bPpj.png)
fetch、事件回调、setTimeout、setInterval会压入消息队列，消息队列在调用栈清空后执行，先入先出
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bSAS.png)
使用promise、async await创建的异步操作会被放置于微任务队列，会在调用栈清空时立即执行，先于消息队列执行
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bptg.png)

[浏览器事件循环机制（event loop）](https://juejin.cn/post/6844903606466904078)
[2分钟了解 JavaScript Event Loop](https://www.bilibili.com/video/BV1kf4y1U7Ln?from=search&seid=2586724673120864651)

#### 请求的方法有哪些 option是什么含义

GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE

##### HEAD

HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。

##### CONNECT

CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

##### OPTIONS

OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

##### TRACE

TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

[HTTP请求方法详解](https://itbilu.com/other/relate/EkwKysXIl.html)

#### 网站漏洞的攻击方式和预防

网络安全攻击方式

##### DDoS攻击

DDoS是最常见的一种攻击方式，攻击者通过向某一个站点服务器反复发送请求，导致服务器无法承载大量的请求而产生“拒绝服务”，这就导致正常的服务无法进行，影响我们服务器的使用。

##### 获取账号和密码

这类攻击会存在一定的技术性。一般来说，攻击者会利用程序来抓取数据包，获取口令和数据内容，通过侦听程序在来监视网络数据流，进而通过分析获取用户的登录账号和密码。

##### SQL注入

SQL注入的攻击手段主要是利用后台的漏洞，通过URL将关键SQL语句带入程序，在数据库中进行破坏。许多的攻击者会使用F12或者postman等拼装ajax请求，将非法的数字发送给后台，造成程序的报错，并展现在页面上，这样攻击者就会知道后台使用的语言和框架了。

##### 恶意小程序

这类攻击的方式主要存在我们使用的程序上面，它们可以通过入侵修改硬盘上的文件、窃取口令等。

##### 木马植入

这种攻击方式主要是通过向服务器植入木马，开启后面，获取服务器的控制权，恶意破坏服务器文件或盗取服务器数据，这类的危害都是比较大的。

[WEB应用常见15种安全漏洞一览](https://blog.fundebug.com/2019/01/25/11-security-flaws-for-web-application/)

#### 最近有新学习什么技术么

##### flutter1.0和2.0的差别有什么

Flutter2.0最大的变化是除了之前已经处于stable渠道的移动设备支持外，
桌面和Web支持也正式宣布进入stable渠道.
