---
title: 前端面试经
abbrlink: 32cd20c6
date: 2021-03-29 10:27:35
tags:
  - 技术积累
  - 前端
  - 面试题
categories:
  - 技术积累
  - 前端
  - 面试题
toc: true
---

![首屏图](https://z3.ax1x.com/2021/03/15/6BreZF.jpg)

<!-- more -->

## 前端面试汇总

### 项目相关

最近的工作经历及项目经验，用到了哪些技术，负责哪些工作。

遇到了什么问题及怎么处理的。

#### 是否封装过组件，封装的过程是什么

[React 组件封装技巧（HOC、Render Props、Hook）](https://zhuanlan.zhihu.com/p/111873208)

#### H5 项目做过什么

##### 屏幕尺寸适配

[都 2020 移动端适配你还用 flexible.js 吗？vw+rem 一行代码搞定](https://juejin.cn/post/6844904029898670088)

优点：不需要引入新的 js，一行代码搞定适配问题
缺点：浏览器兼容性差，IE9 以下不支持，但现代浏览器，特别是移动端，基本都支持

##### em 和 rem 的区别

两者都是相对尺寸

em 继承父级元素的字体大小
rem 是相对 HTML 根元素

#### 防抖和节流

函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。
函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。

##### 防抖

事件触发过程中不触发，并设置延时。当延时完毕才调取，若延时内再次触发则重置延时。

设置状态或使用 lodash

##### 节流

时间戳和定时器一定时间内只能触发一次

[JS 的防抖与节流](https://juejin.cn/post/6844903618827517965)

#### babel 的作用

Babel 是一个广泛使用的转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。 这意味着，你可以现在就用 ES6 编写程序，而不用担心现有环境是否支持。

#### webpack 的 loader 和 plugin 的区别

loader 一般是将某个语法统一处理为统一的语法
plugin 一般是在打包前或打包后对结果进行再次操作

loader:让 webpack 能够处理非 js 文件(自身职能理解 js)，然后你就可以利用 webpack 的打包能力，对它们进行处理。
例如：css-loader、style-loader、postcss-loader、sass-loader

plugins:从打包优化和压缩，一直到重新定义环境中的变量.
例如：uglify-webpack-plugin、clean-webpack-plugin、babel-polyfill

loader 用于加载待打包的资源
plugin 用于扩展 webpack
loader：webpack 自身只支持 js 和 json 这两种格式的文件，对于其他文件需要通过 loader 将其转换为 commonJS 规范的文件后，webpack 才能解析到
plugin：是用于在 webpack 打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle 文件优化等操作

#### 组件库发布至 npm

这个是建立一个私有的 组件库
[npm 私有仓库搭建](https://www.cnblogs.com/zycbloger/p/sinopia.html)

搭建 注册 发布 使用
[npm 私有仓库搭建【verdaccio】](https://www.jianshu.com/p/c61f08b7cb88)

[手把手教你搭建 npm 私有仓库及发布高质量的 npm 包](https://my.oschina.net/u/4292771/blog/3306024)

#### 路由 hash 和 history 有什么差别

- hash 模式是通过改变锚点(#)来更新页面 URL，并不会触发页面重新加载，我们可以通过 window.onhashchange 监听到 hash 的改变，从而处理路由。
- history 模式是通过调用 window.history 对象上的一系列方法来实现页面的无刷新跳转。

##### hash

hash，原本用来结合锚点控制页面视窗的位置，具有以下特点：

- 可以改变 URL，但不会触发页面重新加载（hash 的改变会记录在 window.hisotry 中）因此并不算是一次 http 请求，所以这种模式不利于 SEO 优化
- 只能修改#后面的部分，因此只能跳转与当前 URL 同文档的 URL
- 只能通过字符串改变 URL
- 通过 window.onhashchange 监听 hash 的改变，借此实现无刷新跳转的功能。

##### history

根据 Mozilla Develop Network 的介绍，调用 history.pushState() 相比于直接修改 hash，存在以下优势

- 新的 URL 可以是与当前 URL 同源的任意 URL，也可以与当前 URL 一样，但是这样会把重复的一次操作记录到栈中
- 通过参数 stateObject 可以添加任意类型的数据到记录中
- 可额外设置 title 属性供后续使用
- 通过 pushState、replaceState 实现无刷新跳转的功能。

###### history 常用方法

- back()：后退到上一个路由；
- forward()：前进到下一个路由，如果有的话；
- go(number)：进入到任意一个路由，正数为前进，负数为后退；
- pushState(obj, title, url)：前进到指定的 URL，不刷新页面；
- replaceState(obj, title, url)：用 url 替换当前的路由，不刷新页面；

前面的 hashchange，你只能改变#后面的 url 片段。而 pushState 设置的新 URL 可以是与当前 URL 同源的任意 URL。
history 模式则会将 URL 修改得就和正常请求后端的 URL 一样,如后端没有配置对应/user/id 的路由处理，则会返回 404 错误。

#### 跨域如何处理

1、 通过 jsonp 跨域
2、 document.domain + iframe 跨域
3、 location.hash + iframe
4、 window.name + iframe 跨域
5、 postMessage 跨域
6、 跨域资源共享（CORS）
7、 nginx 代理跨域
8、 nodejs 中间件代理跨域
9、 WebSocket 协议跨域

[前端常见跨域解决方案](https://segmentfault.com/a/1190000011145364)

#### 除了 dayjs 日期库还有用过其他日期库么

moment.js 和 dayjs 的差别

#### git 提交的时候习惯用命令还是图形化管理工具

##### sourseTree 的校验如何实现的

##### git 插件如何提交

#### eslint 是否了解

指定规范

[Eslint 超简单入门教程](https://www.jianshu.com/p/ad1e46faaea2)

#### 小程序是否接触过

做了一版小程序

##### 小程序如何获取 token

1. 微信小程序通过访问 wx.login 获得一个 code，返回给后台
2. 后台拿着这个 code，调用腾讯的接口，获取到 openid、seesion-key 等信息，openid 是用户唯一的
3. 后台拿着 openid 去数据库中检查，该用户是否是第一次登陆
   1. 如果是第一次登陆，那么就新建一个用户--UserAcount；如果不是第一次登陆，就修改该用户的最后登录时间
   1. 不管是不是第一次登录，都有了一个用户
4. 然后根据用户的信息利用 JWT 生成 token，下发给微信小程序

[小程序开发之获取 token 值](https://www.dazhuanlan.com/2019/12/16/5df6867423c68/)

#### 混合开发用过什么 与原生交互如蓝牙图片等

### 浏览器相关

#### cookie SessionStorage LocalStorage 的差别

相同点：

- 都是存储数据，存储在 web 端，并且都是同源

不同点：

1. cookie 只有 4K 小 并且每一次请求都会带上 cookie 体验不好，浪费带宽
1. session 和 local 直接存储在本地，请求不会携带，并且容量比 cookie 要大的多(sessionStorage 约 5M、localStorage 约 20M)
1. session 是临时会话，当窗口被关闭的时候就清除掉 ，而 local 永久存在，cookie 有过期时间
1. cookie 和 local 都可以支持多窗口共享，而 session 不支持多窗口共享 但是都支持 a 链接跳转的新窗口

cookie 数量和长度都有限制，Web Storage 解决了这样的限制，且 localStorage 做到了永久储存。
但是 Cookie 也是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，
而 Web Storage 仅仅是为了在本地“存储”数据而生。

web 存储的特点

1. 设置、读取方便
2. 容量较大，sessionStorage 约 5M、localStorage 约 20M
3. 只能存储字符串，可以将对象 JSON.stringify() 编码后存储

sessionStorage

1. 生命周期为关闭当前页面窗口
2. 不能多窗口下数据可以共享 （同源策略，百度家的 local 阿里他们家是拿不到）
3. 补充：通过跳转可以 运用场景： 页面跳转的时候可以通过 session 实现数据共享 在一些单页面（spa）的运用中，进行页面传值的时候比较有用

localStorage

1. 永久生效，除非手动删除或用代码删除
2. 可以多窗口共享（同源策略）
3. 运用场景：一些不涉及到安全的一些数据（不要太过庞大）都可以存储到本地

[cookie、sessionStorage、localStorage 详解及应用场景](https://segmentfault.com/a/1190000010400892)

##### AB 相同页面 LocalStorage 是否相互影响

A 页面改变 LocalStorageB 页面如何监听到

- 同一浏览器打开了两个同源页面
- 其中一个网页修改了 localStorage
- 另一网页注册了 storage 事件

[监听 localStorage 变化](https://www.jianshu.com/p/519a1b42d659)

#### H5 缓存

[H5 缓存机制浅析 - 移动端 Web 加载性能优化](https://segmentfault.com/a/1190000004132566)

#### 资源缓存有哪些类型

HTML
JavaScript
CSS、SCSS
图片
SVG
视频、音频和字幕
字体文件

#### 为什么会出现缓存 200 和 304 是怎么发生的

请求 200 还是请求 304 是根据什么区分的

首次请求：200
缓存有效期内请求：200(from cache)——再次请求文件未超时不发送请求
缓存过期后请求：304（Not Modified)——文件缓存超时，发送请求到服务器，并携带本地缓存的文件信息，服务器对比信息(最后修改时间)，可继续使用时，返回 304 表示可据需使用

[HTTP 304 与 200 区别](https://blog.csdn.net/apple_osp/article/details/106717505)

#### Http 请求状态码有哪些及含义

- 100:信息响应
- 200:成功响应
- 300:重定向
  - 304: Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。
- 400:客户端响应
- 500:服务端响应
  - 502:此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。
  - 504:当服务器作为网关，不能及时得到响应时返回此错误代码。

#### http2.0 和 http1.x 的区别

- http1 的解析是基于文本协议的各式解析,而 http2.0 的协议解析是二进制格式,更加的强大
- 多路复用(Mutiplexing) : 一个连接上可以有多个 request,且可以随机的混在一起,每个不同的 request 都有对应的 id,服务端可以通过 request_id 来辨别,大大加快了传输速率
- header 压缩: http1.x 中的 header 需要携带大量信息.而且每次都要重复发送.http2.0 使用 encode 来减少传输的 header 大小.而且客户端和服务端可以各自缓存(cache)一份 header filed 表,避免了 header 的重复传输,还可以减少传输的大小.
- 服务端推送(server push): 可以通过解析 html 中的依赖,智能的返回所需的其他文件(css 或者 js 等),而不用再发起一次请求.

### Vue 相关

#### 如何声明一个全局变量

#### 深度选择器 /deep/

- vue 组件的 scoped 属性的作用
- 在 style 标签上添加 scoped 属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；
- 但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；

#### #$route 和 $router 的区别

$router是VueRouter的实例，在script标签中想要导航到不同的URL,使用$router.push 方法。
返回上一个历史 history 用 $router.to(-1) $route 为当前 router 跳转对象。里面可以获取当前路由的 name,path,query,parmas 等。

$route从当前router跳转对象里面可以获取name、path、query、params等（`<router-link>`传的参数由 this.$route.query 或者 this.$route.params 接收）

$router为VueRouter实例。想要导航到不同URL，则使用$router.push 方法；返回上一个 history 也是使用$router.go 方法

#### params 和 query 的区别?如何获取传递的参数

url 地址显示：query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，
说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示
注意点：query 刷新不会丢失 query 里面的数据 params 刷新会丢失 params 里面的数据。

this.$route.query.name和this.$route.params.name

#### vue-router 的有哪两种模式？ history 模式的问题是是什么？

- hash 模式：即地址栏 URL 中的 # 符号；
- history 模式：window.history 对象打印出来可以看到里边提供的方法和记录长度。利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）
- hash 模式是通过改变锚点(#)来更新页面 URL，并不会触发页面重新加载，我们可以通过 window.onhashchange 监听到 hash 的改变，从而处理路由。
- history 模式是通过调用 window.history 对象上的一系列方法来实现页面的无刷新跳转。

### React 相关

#### 如何搭建 react 项目

creat-react-app

#### 简述 react 脚手架的原理

#### React 生命周期有哪些

![life-cycle](https://z3.ax1x.com/2021/03/29/cP3j8P.png)

生命周期的方法有：

- componentWillMount 在渲染前调用,在客户端也在服务端。
- componentDidMount 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的 DOM 结构，可以通过 this.getDOMNode()来进行访问。 如果你想和其他 JavaScript 框架一起使用，可以在这个方法中调用 setTimeout, setInterval 或者发送 AJAX 请求等操作(防止异步操作阻塞 UI)。
- componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化 render 时不会被调用。
- shouldComponentUpdate 返回一个布尔值。在组件接收到新的 props 或者 state 时被调用。在初始化时或者使用 forceUpdate 时不被调用。可以在你确认不需要更新组件时使用。
- componentWillUpdate 在组件接收到新的 props 或者 state 但还没有 render 时被调用。在初始化时不会被调用。
- componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。
- componentWillUnmount 在组件从 DOM 中移除之前立刻被调用。

即将弃用：

- componentWillMount
- componentWillReceiveProps
- componentWillUpdate

新增：

- getDerivedStateFromProps
- getSnapshotBeforeUpdate

[React 的生命周期变化](https://juejin.cn/post/6844904005152276487)

#### Hook

useState 扁平化存储数据
useEffect 初始化时、监听某个或某几个值变化、监听卸载

[谈谈 react hooks 的优缺点](https://zhuanlan.zhihu.com/p/88593858)

#### react 渲染虚拟 dom 的过程

#### react 列表的 keys 的作用是什么

Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。

一般使用 id，如果没有使用 index。

不推荐使用 index，在可调整排序的列表中性能较差。

#### react 和 vue 的差别有哪些

相同点：

- 都使用 Virtural DOM
- 都使用组件化思想，流程基本一致
- 都是响应式，推崇单向数据流
- 都有成熟的社区，都支持服务端渲染

不同点：

Vue 推崇灵活易用（渐进式开发体验），数据可变，双向数据绑定（依赖收集）
React 推崇函数式编程（纯组件），数据不可变以及单向数据流

Vue 推崇 template（简单易懂，从传统前端转过来易于理解）、单文件 vue
React 推崇 JSX、HOC、all in js

[Vue 和 React 区别](https://juejin.cn/post/6844904158093377549)

#### react 和 vue 的优缺点

React.js 的优点：灵活性和响应性、虚拟 DOM、丰富的 JavaScript 库、可扩展性、不断发展、Web 或移动平台

- 灵活性和响应性：它提供最大的灵活性和响应能力。
- 虚拟 DOM：由于它基于文档对象模型，因此它允许浏览器友好地以 HTML，XHTML 或 XML 格式排列文档。
- 丰富的 JavaScript 库：来自世界各地的贡献者正在努力添加更多功能。
- 可扩展性：由于其灵活的结构和可扩展性，React 已被证明对大型应用程序更好。
- 不断发展： React 得到了 Facebook 专业开发人员的支持，他们不断寻找改进方法。
- Web 或移动平台： React 提供 React Native 平台，可通过相同的 React 组件模型为 iOS 和 Android 开发本机呈现的应用程序。无论是 Web 还是本机移动开发，React 都是大多数用户界面设计平台的理想选择。

React.js 的缺点：陡峭的学习曲线

- 陡峭的学习曲线：由于复杂的设置过程，属性，功能和结构，它需要深入的知识来构建应用程序。

现在，让我们转到 Vue.js 并谈谈它的优点和缺点：
与 React 相比，Vue.js 的下载量更少，并且主要用于构建有吸引力的单页面应用程序和 Web 应用程序。但是，Vue.js 具有适应性强的体系结构，使其成为广泛使用的框架之一，具有最新的库和包。

使用 Vue.Js 的优点：易于使用、更顺畅的集成、更好的性能，更小的尺寸、精心编写的文档、适应性

- 易于使用： Vue.js 包含基于 HTML 的标准模板，可以更轻松地使用和修改现有应用程序。
- 更顺畅的集成：无论是单页应用程序还是复杂的 Web 界面，Vue.js 都可以更平滑地集成更小的部件，而不会对整个系统产生任何影响。
- 更好的性能，更小的尺寸：它占用更少的空间，并且往往比其他框架提供更好的性能。
- 精心编写的文档：通过详细的文档提供简单的学习曲线，无需额外的知识; HTML 和 JavaScript 将完成工作。
- 适应性：整体声音设计和架构使其成为一种流行的 JavaScript 框架。它提供无障碍的迁移，简单有效的结构和可重用的模板。

使用 Vue.js 的缺点：市场份额小。世界范围内的外企有刻意回避使用的情况。

- 与 Angular 和 React 相比，Vue.js 框架的市场份额仍然很小。它正在快速流行，但与此同时，在使用 Vue.js 时，可能会出现大规模应用程序开发方面的问题。
  好吧，考虑到其现代功能，速度和灵活性，Vue.js 有可能实现 Web 应用程序开发的里程碑。

### JS 相关

#### 检测变量的类型并区分数组和对象

| 值               | 类型        |
| ---------------- | ----------- |
| typeof 1         | "number"    |
| typeof NaN       | "number"    |
| typeof "1"       | "string"    |
| typeof true      | "boolean"   |
| typeof undefined | "undefined" |
| typeof null      | "object"    |
| typeof []        | "object"    |
| typeof {}        | "object"    |

- 如果返回 number，判断是否是 NAN，isNaN(a) ，
- 首先使用 typeof 判断，如果返回 object，判断是否为 null
- 最后使用 toString 如果是"[object Object]”是对象，否则是数组。

[javascript 判断数据类型的几种方法](https://segmentfault.com/a/1190000018160547)

#### 对比对象 A、B 是否相等()

[JavaScript 中，如何判断两个对象是否相等？](https://juejin.cn/post/6844903802298974221)

- 判断 A===B 返回 true
- 判断 A 和 B 长度是否相等
  - 如果不等返回 false
- 遍历对比

##### js 获取对象长度

对象无法直接获取 length，可以使用原生的 Object.keys 获取

```js
var objA = { name: "Tom", sex: "male", age: "18" };
var objB = { name: "Tom", sex: "male", age: "18" };
var arr = Object.keys(objA);
console.log(arr); // ['name','sex','age']
console.log(arr.length); // 3

// 伪代码
arr.forEach((item) => {
  objA[item] === objB[item];
});
```

#### 多维转一维数组

```js
var arr = [1, 2, [3, 4, [5], 6], 7];
```

- 递归
- toString 正则处理
- Array​.prototype​.flat(Infinity)
- 扩展运算符

递归

> 递归的遍历每一项，若为数组则继续遍历，否则 concat

```js
let arr = [
  [1, 2, [3, 4], 5],
  [6, 7, 8],
  [[9, 10], 11],
];
function flat(arr) {
  let result = [];
  arr.map((item) => {
    if (Array.isArray(item)) {
      result = result.concat(flat(item));
    } else {
      result.push(item);
    }
  });
  return result;
}
console.log(flat(arr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

扩展运算符

> ... 用于取出参数对象的所有可遍历属性，拷贝到当前对象中

```js
let arr = [
  [1, 2, [3, 4], 5],
  [6, 7, 8],
  [[9, 10], 11],
];
function flat(arr) {
  while (arr.some((item) => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
}
console.log(flat(arr)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
```

[扁平化数组的几种方法](https://blog.csdn.net/qq_38128179/article/details/89950590)

#### 变量提升函数提升

[js 中的变量提升和函数提升](https://blog.csdn.net/kontar123/article/details/83508740)

#### 前端模块化的规范

CommonJS： 在 NodeJS 中实现。主要方法是 exports 和 require
AMD：提前执行依赖-尽早执行 requireJs
CMD：按需执行依赖-懒执行 seaJs
ES6: import 和 export

#### ES6 有哪些新特性

1. 不一样的变量声明：const 和 let
2. 模板字符串
3. 箭头函数（Arrow Functions）
4. 函数的参数默认值
5. Spread / Rest 操作符
6. 二进制和八进制字面量
7. 对象和数组解构
8. 对象超类
9. for...of 和 for...in
10. ES6 中的类

[ES6 中常用的 10 个新特性讲解](https://juejin.cn/post/6844903618810757128)

##### 箭头函数能作为构造函数吗

- 从上面的运行结果也可以看到箭头函数与构造函数相比，缺少了很多东西，比如：caller，arguments，prototype，但同时也可以看到，箭头函数是有**proto**属性的，所以箭头函数本身是存在原型链的，他也是有自己的构造函数的，但是原型链到箭头函数这一环就停止了，因为它自己没有 prototype 属性，没法让他的实例的**proto**属性指向，所以箭头函数也就无法作为构造函数。
- 同时我们可以看到，由于箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数，不能绑定 this，所以 call()和 apply()的第一个参数会被忽略。

[箭头函数为什么不能作为构造函数？](https://blog.csdn.net/weixin_42798473/article/details/105319353)

#### 原型、原型链是什么

##### 原型是什么

JS 中每个函数都存在有一个原型对象属性 prototype。并且所有函数的默认原型都是 Object 的实例。

##### 原型链是什么

原型链，简单理解就是原型组成的链，对象的**proto**它的是原型，而原型也是一个对象，也有**proto**属性，
原型的**proto**又是原型的原型，就这样可以一直通过**proto**想上找，这就是原型链，当向上找找到 Object 的原型的时候，这条原型链就算到头了。

##### 原型链作用

原型链实现了继承。原型链存在两个问题：

1. 包含引用类型值的原型属性会被所有实例共享。
2. 在创建子类型时，无法向超类型的构造函数中传递参数。

##### 如何检测它的原型链

```js
prototypeObject.isPrototypeOf(object);
```

[JS isPrototypeOf()方法：检测一个对象是否存在于另一个对象的原型链中](http://c.biancheng.net/view/5801.html)

##### 实例的原型链的上一层指向什么

构造函数的 protoType

#### New 关键词干了什么

1. 创建一个新对象
1. 将新对象的*proto*指向构造函数的 prototype 对象
1. 将构造函数的作用域赋值给新对象 （也就是 this 指向新对象）
1. 执行构造函数中的代码（为这个新对象添加属性）
1. 返回新的对象

```js
var Obj = {};
Obj._proto_ = Person.prototype();
Person.call(Obj);
```

[js 中的 new 关键字做了什么？](https://blog.csdn.net/weixin_34038293/article/details/92886267)

#### 事件监听函数参数有什么

event、function、Boolean

event：监听什么事件
function：触发什么方法
Boolean：是否冒泡

#### Promise

Promise(resolve, reject)和 Promise.all([])

##### promise 代码的输出结果是什么

```js
new Promise((resolve) => {
  resolve("ok");
  throw new Error("err");
})
  .then(console.log)
  .catch(console.error);
```

> 输出结果是什么

(ok)

> 为什么不是 err

[promise 执行顺序总结](https://yuanfentiank789.github.io/2019/11/07/promise%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%80%BB%E7%BB%93/)

##### promise 有哪些状态是如何改变的

promise 有 3 种状 态： pending、fulfilled 或 rejected。
状态改变只能是 pending->fulfilled 或者 pending-> rejected，状态一旦改变则不能再变。

##### promise 的.then 的参数类型是什么

Promise 类型的对象

[Promise.then 函数返回值类型与参数传递](https://blog.csdn.net/weixin_41728198/article/details/103450075)

##### 手动实现 Promise.all

```js
Promise.all2 = function (promises) {
  return new Promise(function (resolve, reject) {
    const len = promises.length;
    let count = 0,
      results = new Array(len);
    for (let i = 0; i < len; i++) {
      Promise.resolve(promises[i]).then(
        (value) => {
          count++;
          results[i] = value;
          if (count === len) {
            return resolve(results);
          }
        },
        (reason) => {
          return reject(reason);
        }
      );
    }
  });
};

let p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("p1 resolved");
  }, 1000);
});

let p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("p2 resolved");
  }, 2000);
});

// Promise.all
console.time("cost");
Promise.all2([p1, p2]).then((res) => {
  console.log(res);
  console.timeEnd("cost");
});
```

[理解和使用 Promise.all 和 Promise.race](https://www.jianshu.com/p/7e60fc1be1b2)

#### 使用 promise 实现 sleep()

```js
(async function () {
  /**
   * s 休眠时长， 单位：秒
   */
  function sleep(s) {
    s = s || 0;
    s = parseInt(s) * 1000;
    let now = +new Date();
    let timer = null;
    return new Promise((resolve, reject) => {
      timer = setInterval(() => {
        if (now + s < +new Date()) {
          clearInterval(timer);
          resolve(true);
        }
      }, 10);
    });
  }

  console.log(`start: ${new Date()}`);
  await sleep(3); // 休眠3秒
  console.log(`end  : ${new Date()}`);
})();
```

[JavaScript 通过 Promise 实现 sleep 方法](https://blog.csdn.net/u013137242/article/details/83054750)

#### 常见设计模式

- 创建型模式
  - 工厂模式
  - 单例模式
- 结构型模式
  - 适配器
  - 组合模式
  - 装饰模式
  - 代理模式
- 行为模式
  - 观察者模式
  - 策略模式
  - 模板方法模式

##### 工厂模式

在父类中提供一个创建对象的接口，以允许子类根据具体的需要创建对象。

**应用场景**：

1. 当你在编码过程中，无法预知要使用的对象的确切类别时

**设计原则**：

1. 单一职责（工厂类负责所有对象的创建）
2. 开闭原则（在增加新的类型时，客户端无需修改代码）

##### 单例模式

保证一个类只有一个实例，并提供一个全局的访问方式。

**应用场景**：

1. 当你需要保证一个类只有一个实例时。比如：控制某个共享资源的访问权限。
2. 当你需要提供一个全局访问某个实例的方式，同时又要保护该实例不会被复写时。

##### 策略模式

能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

**应用场景**：

1. 当你有许多仅在执行某些行为时略有不同的相似类时。
2. 当你想要将类的业务逻辑与其算法实现细节隔离开来时。

##### 观察者模式

允许你定义一种订阅机制，可在对象事件发生时通知多个“观察”该对象的其他对象。

**应用场景**：

1. 当一个对象状态的改变需要引起其他对象的改变时

[浅析常用设计模式及应用场景](https://xie.infoq.cn/article/b81e720d57e4d453c5067aaa1)

#### 常见数据结构

- 数组
- 栈
- 队列
- 链表
- 图
- 树
- 前缀树
- 哈希表

### HTML 相关

#### 圣杯布局双飞翼布局

![圣杯布局双飞翼布局](https://z3.ax1x.com/2021/03/29/cP8SKS.jpg)

##### 圣杯布局

- 首先把 left、middle、right 都放出来
- 给它们三个设置上 float: left, 脱离文档流；
- 一定记得给 container 设置上 overflow: hidden; 可以形成 BFC 撑开文档
- left、right 设置上各自的宽度
- middle 设置 width: 100%;

接下来比较重要了：

- 给 left、middle、right 设置 position: relative;
- left 设置 left: -leftWidth, right 设置 right: -rightWidth;
- container 设置 padding: 0, rightWidth, 0, leftWidth;

##### 双飞翼布局

- 首先把 left、middle、right 都放出来, middle 中增加 inner
- 给它们三个设置上 float: left, 脱离文档流；
- 一定记得给 container 设置上 overflow: hidden; 可以形成 BFC 撑开文档
- left、right 设置上各自的宽度
- middle 设置 width: 100%;

接下来与圣杯布局不一样的地方：

- left 设置 margin-left: -100%, right 设置 right: -rightWidth;
- container 设置 padding: 0, rightWidth, 0, leftWidth;

[深入理解圣杯布局和双飞翼布局](https://juejin.cn/post/6844903817104850952)

#### 相邻元素 margin 重叠产生的原因及解决方法

[垂直方向 margin 重叠原因与解决方法](https://my.oschina.net/u/2612473/blog/2221555)

##### 什么是 BFC 为什么会有 BFC 的概念

什么是 BFC：Block Formatting Context，解释为块级格式化上下文

一个 HTML 元素要创建 BFC，则满足下列的任意一个或多个条件即可：

1、float 的值不是 none。（float:left 或者 float:right）
2、position 的值不是 static 或者 relative。（position:absolute 或者 position:fixed）
3、display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex
4、overflow 的值不是 visible（overflow:hidden、overflow:scroll）
5、父元素与正常文件流的子元素（非浮动子元素）自动形成一个 BFC

[什么是 BFC？看这一篇就够了](https://blog.csdn.net/sinat_36422236/article/details/88763187)
[BFC 是什么？](https://zhuanlan.zhihu.com/p/45515245)

BFC 特性/功能

- 父亲管儿子(子元素浮动，父元素不再塌陷)
- 兄弟之间划清界限(兄弟元素其一浮动重叠，另一个元素设置 BFC 便不再重叠)

### CSS 相关

#### div 垂直水平居中

方法 1：绝对定位+margin:auto

```css
div {
  width: 200px;
  height: 200px;
  background: green;

  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  right: 0;
  margin: auto;
}
```

方法 2：绝对定位+负 margin

```css
div {
  width: 200px;
  height: 200px;
  background: green;

  position: absolute;
  left: 50%;
  top: 50%;
  margin-left: -100px;
  margin-top: -100px;
}
```

方法 3：绝对定位+transform

```css
div {
  width: 200px;
  height: 200px;
  background: green;

  position: absolute;
  left: 50%; /* 定位父级的50% */
  top: 50%;
  transform: translate(-50%, -50%); /*自己的50% */
}
```

方法 4：flex 布局

```css
.box {
  height: 600px;

  display: flex;
  justify-content: center; //子元素水平居中
  align-items: center; //子元素垂直居中
  /* aa只要三句话就可以实现不定宽高水平垂直居中。 */
}
.box > div {
  background: green;
  width: 200px;
  height: 200px;
}
```

方法 5：table-cell 实现居中

设置
display:table-cell;
text-align:center;
vertical-align: middle;

### 其他

#### 前端项目性能优化

- 请求数量：合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域
- 请求带宽：开启 Gzip，精简 JS，移除重复脚本，图像优化，将 Icon 做成字体
- 缓存利用：使用 CDN，使用外部 JS、CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AJAX 可缓存
- 页面结构：样式表放在顶部，脚本放在底部，尽早刷新文档的输出
- 代码校验：避免 CSS 表达式，避免重定向

#### 输入地址后的过程

1. 域名解析
1. 发起 TCP3 次握手
1. 建立 TCP 链接后发起 http 请求
1. 服务器响应 http 请求，浏览器获得 html 代码
1. 浏览器解析 html 代码，并请求 html 中的资源
1. 浏览器对页面进行渲染并呈现给用户

#### 浏览器渲染过程

1. 解析 HTML 生成 DOM 树。
1. 解析 CSS 生成 CSSOM 规则树。
1. 将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。
1. 遍历渲染树开始布局，计算每个节点的位置大小信息。
1. 将渲染树每个节点绘制到屏幕。

[十分钟读懂浏览器渲染流程](https://juejin.cn/post/6844903565610188807)

#### 浏览器循环机制

调用栈先入后出
消息队列先入先出：异步操作-feath、settimeout
微任务在消息队列前执行 promise
![EventLoop](https://z3.ax1x.com/2021/03/29/c9b9hQ.png)
调用栈先进后出
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bPpj.png)
fetch、事件回调、setTimeout、setInterval 会压入消息队列，消息队列在调用栈清空后执行，先入先出
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bSAS.png)
使用 promise、async await 创建的异步操作会被放置于微任务队列，会在调用栈清空时立即执行，先于消息队列执行
![EventLoop](https://z3.ax1x.com/2021/03/29/c9bptg.png)

[浏览器事件循环机制（event loop）](https://juejin.cn/post/6844903606466904078)
[2 分钟了解 JavaScript Event Loop](https://www.bilibili.com/video/BV1kf4y1U7Ln?from=search&seid=2586724673120864651)

#### 请求的方法有哪些 option 是什么含义

GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE

##### HEAD

HEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。

##### CONNECT

CONNECT 方法是 HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。

##### OPTIONS

OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'\*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

##### TRACE

TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。

[HTTP 请求方法详解](https://itbilu.com/other/relate/EkwKysXIl.html)

#### 网站漏洞的攻击方式和预防

网络安全攻击方式

##### DDoS 攻击

DDoS 是最常见的一种攻击方式，攻击者通过向某一个站点服务器反复发送请求，导致服务器无法承载大量的请求而产生“拒绝服务”，这就导致正常的服务无法进行，影响我们服务器的使用。

##### 获取账号和密码

这类攻击会存在一定的技术性。一般来说，攻击者会利用程序来抓取数据包，获取口令和数据内容，通过侦听程序在来监视网络数据流，进而通过分析获取用户的登录账号和密码。

##### SQL 注入

SQL 注入的攻击手段主要是利用后台的漏洞，通过 URL 将关键 SQL 语句带入程序，在数据库中进行破坏。许多的攻击者会使用 F12 或者 postman 等拼装 ajax 请求，将非法的数字发送给后台，造成程序的报错，并展现在页面上，这样攻击者就会知道后台使用的语言和框架了。

##### 恶意小程序

这类攻击的方式主要存在我们使用的程序上面，它们可以通过入侵修改硬盘上的文件、窃取口令等。

##### 木马植入

这种攻击方式主要是通过向服务器植入木马，开启后面，获取服务器的控制权，恶意破坏服务器文件或盗取服务器数据，这类的危害都是比较大的。

[WEB 应用常见 15 种安全漏洞一览](https://blog.fundebug.com/2019/01/25/11-security-flaws-for-web-application/)

#### 最近有新学习什么技术么

##### flutter1.0 和 2.0 的差别有什么

Flutter2.0 最大的变化是除了之前已经处于 stable 渠道的移动设备支持外，
桌面和 Web 支持也正式宣布进入 stable 渠道.
