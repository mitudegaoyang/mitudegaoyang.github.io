---
title: 两数之和
tags:
  - 技术积累
  - LeetCode
  - 两数之和
  - 简单
  - 每日一练
categories:
  - 技术积累
  - LeetCode
abbrlink: d98ef1d2
date: 2020-07-28 14:59:28
---

![首屏图](https://s1.ax1x.com/2020/07/28/aEZnFH.jpg)

<!-- more -->

## LeetCode 题目总结 - 两数之和

### 题目

给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

### 示例

> 给定 nums = [2, 7, 11, 15], target = 9
> &nbsp;
> 因为 nums[**0**] + nums[**1**] = 2 + 7 = 9
> 所以返回 [**0**, **1**]

### 解题

#### 思路一

> 暴力遍历

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    for(var i = 0; i<nums.length; i++){
        for(var j=i+1;j<nums.length;j++){
            if (nums[i]+nums[j]===target) {
                return [i,j]
            }
        }
    }
};
```

#### 思路二

> 利用数组减少查询时间

* 在暴力法中，内层循环查找差值很浪费时间，那么如何减少查询时间呢？利用数组就可以减少查询时间。
* 使用一层循环，每遍历到一个元素就计算该元素与 target 之间的差值 dif，然后以 dif 为下标到数组temp中寻找，如果 `temp[dif]` 有值(即不是 undefined)，则返回两个元素在数组 nums 的下标，如果没有找到，则将当前元素存入数组 temp 中(下标: nums[i], Value: i) 。
* 时间复杂度：O(n)。

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    var temp = [];
    for(var i=0;i<nums.length;i++){
        // dif等同于目标数字-数组i值后的值
        var dif = target - nums[i];
        // 判断dif是否存在
        if(temp[dif] != undefined){
            // 返回dif的角标及遍历后的i值
            return [temp[dif],i];
        }
        // 存储num[i]
        temp[nums[i]] = i;
    }
};
```

> 给定 nums = [-1, 2, 7, 11, 15], target = 18
> temp的变化为
> [-1:0]=>[-1:0,2:1]=>[-1:0,2:1,7:2]
> 判断temp[7] != undefined从而确定值为[2,3]

#### 思路三

> 使用while循环

* 用while循环从后往前遍历。
* 每次遍历先pop最后一个值，再通过indexOf来查找是否有对应的差，pop的好处是为了防止两个数相等。
* 如果有对应的值，索引就是indexOf和数组的长度。

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    let i = nums.length;
    while(i > 1) {
        // 获取nums最后一个值，并将其删除
        let last = nums.pop();
        // 判断目标值减最后一个值的数是否存在于原数组中
        if (nums.indexOf(target - last) > -1) {
            return [nums.indexOf(target - last), nums.length]
        }
        i--
    }
};
```

## 参考资料

* [两数之和](https://leetcode-cn.com/problems/two-sum/)
* [两数之和(Java、JS 实现) 时间复杂度:O(n)](https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-java-jsshi-xian-shi-jian-fu-za-du/)
* [两数之和-lin-536](https://leetcode-cn.com/problems/two-sum/solution/liang-shu-zhi-he-by-lin-536/)
