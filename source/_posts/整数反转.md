---
title: 整数反转
tags:
  - 技术积累
  - LeetCode
  - 整数反转
  - 简单
  - 每日一练
categories:
  - 技术积累
  - LeetCode
abbrlink: e3e2e8e
date: 2021-11-21 10:01:29
---

![首屏图](https://z3.ax1x.com/2021/11/25/oF0jxI.jpg)

<!-- more -->

## LeetCode 题目总结 - 整数反转

### 题目

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围  [−2^31^,  2^31^ − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。

#### 示例 1

```text
输入：x = 123
输出：321
```

#### 示例 2

```text
输入：x = -123
输出：-321
```

#### 示例 3

```text
输入：x = 120
输出：21
```

#### 示例 4

```text
输入：x = 0
输出：0
```

#### 提示

> -2^31^ <= x <= 2^31^ - 1

#### 解法一: 数组翻转法

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function (x) {
  // 特殊值处理
  if (x > 2147483647 || x < -2147483648) {
    return 0;
  }
  // 初始化数值
  let flag = x > 0 ? 1 : -1;
  let str = x > 0 ? x.toString() : (-x).toString();
  let arr = str.split('');
  let num = 0;
  // 转化
  num = arr.reverse().join('') * flag;
  // 校验转化值大小
  if (num > 2147483647 || num < -2147483648) {
    return 0;
  }
  // 输出
  return num;
};
```

#### 解法二: 模运算转换法

##### 解题思路

首先我们想一下，怎么去反转一个整数？
用栈？或者把整数变成字符串，再去反转这个字符串？
这两种方式是可以，但并不好。实际上我们只要能拿到这个整数的 **末尾数字** 就可以了。

以 `12345` 为例，先拿到 `5`，再拿到 `4`，之后是 `3`，`2`，`1`，
我们按这样的顺序就可以反向拼接处一个数字了，也就能达到 **反转** 的效果。
怎么拿末尾数字呢？好办，用取模运算就可以了

![1](https://z3.ax1x.com/2021/11/24/oP0Bgx.jpg)

1. 将 `12345 % 10` 得到 5，之后将 `12345 / 10`
2. 将 `1234 % 10` 得到 4，再将 `1234 / 10`
3. 将 `123 % 10` 得到 3，再将 `123 / 10`
4. 将 `12 % 10` 得到 2，再将 `12 / 10`
5. 将 `1 % 10` 得到 1，再将 `1 / 10`

这么看起来，一个循环就搞定了，循环的判断条件是 x>0
但这样不对，因为忽略了 **负数**

循环的判断条件应该是 `while(x!=0)`，无论正数还是负数，按照上面不断的`/10` 这样的操作，最后都会变成 0，所以判断终止条件就是`!=0`
有了取模和除法操作，对于像 `12300` 这样的数字，也可以完美的解决掉了。

看起来这道题就这么解决了，但请注意，题目上还有这么一句

> 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为  [−2^31^, 2^31^ − 1]。

也就是说我们不能用 `long` 存储最终结果，而且有些数字可能是合法范围内的数字，但是**反转**过来就超过范围了。
假设有 `1147483649` 这个数字，它是小于最大的 32 位整数 `2147483647` 的，但是将这个数字反转过来后就变成了 `9463847411`，这就比最大的 32 位整数还要大了，这样的数字是没法存到 `int` 里面的，所以肯定要返回 `0`(溢出了)。

复杂度分析

- 时间复杂度 O(log∣x∣)。翻转的次数即 xx 十进制的位数。
- 空间复杂度 O(1)O(1)

代码实现

```js
var reverse = function (x) {
  // 初始化
  let rev = 0;
  while (x !== 0) {
    // 每次取末尾数字
    const digit = x % 10;
    x = ~~(x / 10);
    rev = rev * 10 + digit;
    // 判断是否 大于 最大32位整数或 小于 最小32位整数
    if (rev < Math.pow(-2, 31) || rev > Math.pow(2, 31) - 1) {
      return 0;
    }
  }
  return rev;
};
```

## 参考资料

- [整数反转](https://leetcode-cn.com/problems/reverse-integer/)
- [JS 按位非运算符(`~`)及双非(`~~`)的使用](https://segmentfault.com/a/1190000003731938)
