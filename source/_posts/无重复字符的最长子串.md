---
title: 无重复字符的最长子串
tags:
  - 技术积累
  - LeetCode
  - 无重复字符的最长子串
  - 中等
  - 每日一练
categories:
  - 技术积累
  - LeetCode
abbrlink: 4cd9164b
date: 2020-08-18 14:49:51
---

![首屏图](https://s1.ax1x.com/2020/08/18/duIHij.jpg)

<!-- more -->

## LeetCode 题目总结 - 无重复字符的最长子串

### 题目

给定一个字符串，请你找出其中不含有重复字符的**最长子串**的长度。

### 示例

#### 示例 1

```text
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

#### 示例 2

```text
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

#### 示例 3

```text
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

### 解题

#### 解法一: 维护数组

**解题思路：**使用一个数组来维护滑动窗口

遍历字符串，判断字符是否在滑动窗口数组里

- 不在则`push`进数组
- 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符`push`进数组
- 然后将`max`更新为当前最长子串的长度

遍历完，返回`max`即可

**画图帮助理解一下：**

![维护数组](https://s1.ax1x.com/2020/08/19/dQtNVO.jpg)

**代码实现：**

```js
var lengthOfLongestSubstring = function (s) {
  // 创建空数组及最大长度0
  let arr = [],
    max = 0;
  // 遍历字符串
  for (let i = 0; i < s.length; i++) {
    // 获取当前字符在数组中的下标(-1则不存在)
    let index = arr.indexOf(s[i]);
    // 当前字符存在时删除数组中与当前字符相同的字符之前的元素
    if (index !== -1) {
      arr.splice(0, index + 1);
    }
    // 将当前字符push进数组
    arr.push(s.charAt(i)); // charAt() 方法可返回指定位置的字符。
    // 存储最大值(若当前数组的长度比最大值大则存储)
    max = Math.max(arr.length, max);
  }
  return max;
};
```

代码优化

```js
var lengthOfLongestSubstring = function (s) {
  let arr = [],
    max = 0;
  for (let i = 0; i < s.length; i++) {
    let index = arr.indexOf(s[i]);
    if (index !== -1) {
      // 只有当数组需要删除相同元素时才做最大值的存储
      max = Math.max(arr.length, max);
      arr.splice(0, index + 1);
    }
    arr.push(s.charAt(i));
  }
  // 若字符串中所有字符均不同 至少进行一次最大值的存储
  max = Math.max(arr.length, max);
  return max;
};
```

**时间复杂度：**O(n^2^)， 其中`arr.indexOf()`时间复杂度为 O(n)，`arr.splice(0, index+1)`的时间复杂度也为 O(n)

**空间复杂度：**O(n)

#### 解法二: 维护下标

**解题思路：**使用下标来维护滑动窗口

**代码实现：**

```js
var lengthOfLongestSubstring = function (s) {
  // 初始化下标值0及最大长度0
  let index = 0,
    max = 0;
  // i为滑动窗口最左侧的元素下标 j为最右侧元素下标 遍历字符串
  for (let i = 0, j = 0; j < s.length; j++) {
    // 查看当前元素是否存在于滑动窗口中
    index = s.substring(i, j).indexOf(s[j]); // substring() 方法用于提取字符串中介于两个指定下标之间的字符。
    // 若存在 将最左侧元素的下标 更新为与当前元素相同的最左侧元素下标+1
    if (index !== -1) {
      i = i + index + 1;
    }
    // 记录最大值 滑动窗口最右侧下标-最左侧下标+1
    max = Math.max(max, j - i + 1);
  }
  return max;
};
```

- 时间复杂度：O(n^2^)

- 空间复杂度：O(n)

#### 解法三: 优化的 Map

**解题思路：**

使用`map`来存储当前已经遍历过的字符，`key`为字符，`value`为下标

使用`i`来标记无重复子串开始下标，`j`为当前遍历字符下标

遍历字符串，判断当前字符是否已经在`map`中存在，存在则更新无重复子串开始下标`i`为相同字符的下一位置，
此时从`i`到`j`为最新的无重复子串，更新`max`，将当前字符与下标放入`map`中

最后，返回`max`即可

**画图帮助理解一下：**

![map](https://s1.ax1x.com/2020/08/19/dlbEvQ.jpg)

**代码实现：**

```js
var lengthOfLongestSubstring = function (s) {
  // 初始化map及最大值
  let map = new Map(),
    max = 0;
  // 初始化无重复子串开始下标i 当前遍历字符下标j 遍历字符串
  for (let i = 0, j = 0; j < s.length; j++) {
    // 判断当前值是否存在于map中
    if (map.has(s[j])) {
      // 若存在 将无重复子串开始下标i 赋值为重复元素下标+1
      // 注意 赋值时需比较当前查找到的重复元素下标是否比i大
      i = Math.max(map.get(s[j]) + 1, i);
    }
    // 更新无重读子串最大值
    max = Math.max(max, j - i + 1);
    // 更新map中重复字符的下标为最新的下标
    map.set(s[j], j);
  }
  return max;
};
```

**输出查看一下数据的变化：**

- 当数据为`abba`时

![abba](https://s1.ax1x.com/2020/08/19/dlrqER.png)

- 当数据为`abcabcbb`时

![abcabcbb](https://s1.ax1x.com/2020/08/19/dlrLU1.png)

**时间复杂度：**O(n)

**空间复杂度：**O(n)

## 参考资料

- [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
- [无重复字符的最长子串官方解题思路](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/)
- [JavaScript 三种解法：无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/zi-jie-leetcode3wu-zhong-fu-zi-fu-de-zui-chang-zi-/)
