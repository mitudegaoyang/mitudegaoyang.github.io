---
title: 前端知识积累
abbrlink: 70ca98d5
date: 2021-02-15 14:59:30
tags:
  - 技术积累
  - 前端
  - 面试题
categories:
  - 技术积累
  - 前端
  - 面试题
toc: true
---

![首屏图](https://z3.ax1x.com/2021/03/15/6BwUgK.jpg)

<!-- more -->

## web 前端面试题

### HTML5

### CSS3

### JS

#### 原型链和继承

![原型链](https://z3.ax1x.com/2021/03/06/6nomVK.png)

##### 原型链

js 对象独有的**proto**属性，当访问一个对象的属性时，如果该对象内不存在这个属性，会去它的**proto**属性所指向的那个对象（父对象）里找，直到 null

##### proto

对象都有私有属性**proto**（），从对象指向实例原型

##### prototype

函数独有的属性，从一个函数指向一个对象，包含所有实例可共享的属性和方法，任何函数创建时，会默认创建该函数的 prototype 对象

##### constructor

实例的构造函数（constructor）属性，指向实例

##### 总结

所有函数和对象最终都是由 Function 构造函数得来，所以 constructor 属性的终点就是 Function 这个函数。

1. prototype 指向的原型对象又有一个属性 constructor，这个属性也是一个指针，指回原构造函数，即这个方法。
2. **proto**和 constructor 属性是对象所独有的，prototype 属性是函数所独有的。
3. JS 中函数也是一种对象，所以函数也拥有**proto**和 constructor 属性
4. 为什么有 prototype，如果没有，每次新建对象都会继承构造函数的所有属性，方法，浪费性能，用了 prototype 后，属性每个对象的值相同性不高，写在构造函数里，而方法通常是通用的，使用 prototype 可以让每个对象共享同一个方法，而不用每次都 copy 一个，而且能实时更新
5. [JavaScript 原型链和继承](https://www.cnblogs.com/tylerdonet/p/9595436.html)
6. [为什么使用 prototype](https://segmentfault.com/a/1190000000653327)

#### 浅拷贝和深拷贝

- 基本数据类型：名字和值都存在栈中
- 引用数据类型：名字在栈中，值在堆中，栈内存会提供一个引用地址，指向堆内存中的值
- 浅拷贝：
  - for 只遍历第一层
  - assign
  - `=`直接赋值
- 深拷贝：
  - 递归遍历所有层级
  - 利用 JSON 对象【JSON.stringfy() JSON.parse()】
  - 通过 jQuery 的 extend 方法实现深拷贝
  - lodash 函数库实现深拷贝
  - 用 slice 实现对数组的深拷贝,slice() 方法可从已有的数组中返回选定的元素。
  - 使用扩展运算符实现深拷贝
  - 如对象的 value 是基本类型，可以用 Object.assign 来实现深拷贝，但是要把它赋值给一个空对象 assign 第一层是深拷贝，第二层以后是浅拷贝
  - Reflect 法
  - 用 concat 实现对数组的深拷贝
  - 直接使用 var newObj = Object.create(oldObj)，可以达到深拷贝的效果。
  - 手动实现深拷贝

```js
// JSON对象进行深拷贝
function deepClone2(obj) {
  var _obj = JSON.stringify(obj),
    objClone = JSON.parse(_obj);
  return objClone;
} // 无法实现对对象中 方法 的深拷贝，会显示为undefined

// jQuery的extend方法进行深拷贝
var array = [1, 2, 3, 4];
var newArray = $.extend(true, [], array); // true为深拷贝，false为浅拷贝

// lodash方法进行深拷贝
let result = _.cloneDeep(test);
```

#### js 中的堆和栈

- 栈（stack）：简单地数据段，存放在栈中，有固定大小的内存（自动分配），自动释放
  - 基本数据类型：number，string，boolean，undefined，null
  - 栈存储了什么：变量名，基本数据类型值，地址
  - 全局作用域，私有作用域，都属是栈内存，理论上，存储的越少，运行速度越快
  - 先进后出
  - 栈内存回收：作用域销毁（立即销毁，不销毁，不立即销毁）
    - 全局作用域销毁：一般情况不销毁，页面关闭，整个作用域销毁
    - 私有作用域销毁 ：
      - 不销毁
      - 销毁
      - 不立即销毁
- 堆（heap）：动态分配内存，大小不定也不会自动释放
  - 引用类型：栈中存放地址，指向堆中的对象，当我们要获取（函数，数组，对象等）的时候，先从栈中获取地址，然后从堆中获取数据
  - 先进先出
  - 堆存储了什么：引用数据类型的值
  - 内存回收：GC 垃圾回收机制
    - chrome：标记法，每隔一段时间对所有的空间地址检测，如果没有被占用，立即回收
    - ie 和火狐：计数法，空间地址被占用一次+1，空闲一次空间地址-1，如果为 0 被回收

[10 分钟了解 JS 堆、栈以及事件循环的概念](https://juejin.cn/post/6844903618999500808)

#### 闭包

- 闭包函数：声明在一个函数中的函数，叫做闭包函数。
- 闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
- 参数和变量不会被垃圾回收机制回收

```js
function a() {
  var name = 'Shier';
  return function () {
    return name;
  };
}
var b = a();
console.log(b());
// 通过返回函数中返回的内部变量，使函数外部能够使用和访问函数内部变量
```

#### setTimeout

setTimeout 有两个参数，第一个参数为一个函数，我们通过该函数定义将要执行的操作。第二个参数为一个时间毫秒数，表示延迟执行的时间。

```js
var timer = setTimeout(function () {
  console.log('如果不清除我，我将会一秒之后出现。');
}, 1000);

clearTimeout(timer); // 清除之后，通过setTimeout定义的操作并不会执行

for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
// 上述结果返回总为6
// 循环被立即执行，定时器依次放入执行队列中，
// 并分别等待1、2、3、4、5s执行console，
// 在定时器输出的时候，i已经自增完毕，因此输出的均为6

for (var i = 1; i <= 5; i++) {
  (function (i) {
    setTimeout(
      (function timer() {
        // 或者在这里使用闭包
        console.log(i);
      })(i),
      i * 1000
    );
  })(i);
}
// 使用闭包将值存住，输出为123456
```

console 的返回值中，会有两行，一行是一个唯一的 id，其他的是输出的内容
每个 setTimeout 在执行时，会返回一个唯一 ID。在使用时，常常会使用一个变量将这个唯一 ID 保存起来，用以传入 clearTimeout，清除定时器。

#### 事件委托

- DOM 事件流：事件捕获，目标阶段，事件冒泡
  addEventListener（‘click’，function(event){触发事件}, false）默认在事件冒泡阶段触发，默认值 false
- 事件委托：
  事件委托利用了事件冒泡和 event.target，当有一系列子元素都需要绑定事件时，只需要将事件绑定在父元素即可
  - event.currentTarget:事件绑定的元素（绑定在父级元素）
  - event.target:触发事件的源头（所点击的子元素）
  - target：事件目标

#### this 指向，call/apply/bind，回调函数

1. 一般函数,this 指向全局对象 window;
1. 在严格模式下"use strict",为 undefined.
1. 对象的方法里调用,this 指向调用该方法的对象. 【this 指的是，调用函数的那个对象】
1. 构造函数里的 this,指向创建出来的实例.

- call，apply，bind，改变函数运行时的指向，当第一个参数为 null 或 undefind 时，指向 window
  - call：传入参数列表，改变函数指向并立即调用，第一个参数同 apply，第二个参数必须是单个参数列表，不能是数组
  - apply：可以传入数组，第一个参数：要绑定给 this 的值 第二个参数：参数列表（可以是数组）
  - bind：改变 this 指向后，返回的是函数

例子 1：

```js
var obj = {
  name: 'Dot'
};
function printName() {
  console.log(this.name);
}
var dot = printName.bind(obj);
console.log(dot); // function () { … }
dot(); // Dot
//bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。
//而原函数 printName 中的 this 并没有被改变，依旧指向全局对象 window。
```

例子 2：

```js
var a = 1;
var obj1 = {
  a: 2,
  fn: function () {
    console.log(this.a);
  }
};
obj1.fn(); //2
//此时的this是指obj1这个对象，obj1.fn()
//实际上是obj1.fn.call(obj1)，事实上谁调用这个函数，this就是谁
```

例子 3：点击页面，依次输出：document 和 window 对象
解析：点击页面监听 click 事件属于方法调用，this 指向事件源 DOM 对象，即 obj.fn.apply(obj)，setTimeout 内的函数属于回调函数，可以这么理解 f1.call(null,f2)，所以 this 指向 window。

```js
document.addEventListener(
  'click',
  function (e) {
    console.log(this);
    setTimeout(function () {
      console.log(this);
    }, 200);
  },
  false
);
```

#### 数组的常用操作

- concat()
  - 拼接数组：连接两个或更多的数组，并返回结果。
- join()
  - 按字符拼接字符串：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
- splice()
  - 替换元素：删除元素，并向数组添加新元素。
- slice()
  - 截取数组：从某个已有的数组返回选定的元素
- pop()
  - 删除最后一个：删除并返回数组的最后一个元素(改变原数组)
- push()
  - 拼接元素：向数组的末尾添加一个或更多元素，并返回新的长度。
- shift()
  - 删除第一个：删除并返回数组的第一个元素
- unshift()
  - 压入元素：向数组的开头添加一个或更多元素，并返回新的长度。
- reverse()
  - 数组翻转：颠倒数组中元素的顺序。
- sort()
  - 数组排序：对数组的元素进行排序
- toString()
  - 数组转换字符串：把数组转换为字符串，并返回结果。
- valueOf()
  - 返回数组对象的原始值。
- toSource()
  - 返回该对象的源代码。
- toLocaleString()
  - 根据本地时间把 Date 对象转换为字符串。

#### set 和 weakset，map 和 weakmap

#### let 和 const

#### 解构赋值

#### typeof 原理

#### 0.1+0.2 === 0.3 吗，为什么

#### 前端安全 xss 和 csrf

#### 说明 BFC 及其使用

#### js 基本数据类型

#### 循环

#### Js 数组都有哪些方法及其作用、用法、返回值？详细说了一下 splice()

#### Js 数组去重

#### 说明冒泡排序、插入排序实现的思想、步骤、每趟的结果等

#### 什么是二分查找

#### HTTP 协议相关

##### 请求头

##### 响应头

##### 状态码（5 大类）

##### 报文格式

##### 一次 http 完整的过程

##### 详细说一下 Accept - Encoding 的作用，和性能有关系？

##### http 有哪些请求方式？

##### Get 和 post 的区别？

#### Ajax 相关

##### 如何实现

##### 用 jQuery 实现一个 ajax

##### 有没有看过 jQuery 内部是如何实现的？

##### 说说链式调用

#### Application 相关

##### 什么是 Cookie 和 Session？

##### Cookie 和 Session 他们的区别？

##### Js 实现 cookie 和 session 两者有联系吗？

##### localStorage、sessionStorage、cookie 是什么？

#### 垂直居中布局 4 中

#### 浮动引起的问题，如何清除浮动【4 种

#### postion 和 z-index 的关系？

#### DOM 操作：获取、增、删、查、改等操作

#### JS 交换两个节点如何实现？

#### tcp 三次握手四次挥手

#### ES6 有哪些新特性

- let，const
- 箭头函数
- 解构赋值
- set、weakSet、map、weakMap
- proxy
- generator
- reflect
- async、await
- class
- promise

#### 如何设置一个元素不可见 4 中

#### 什么是跨域问题，有哪些跨域方式

#### JS 异步解决方案的发展历程以及优缺点

#### 行内元素和块元素区别，image 标签属于哪种

#### eval

#### Object.assign()

#### reduce 求和

#### 普通函数和构造函数

### http

### ES6

### Vue

### React

#### 有状态组件和无状态组件

性能更高，因为他就是一个函数
由于是无状态组件，所以，无论 props 会否变更，都会重新刷新这个组件

[简述 React 中无状态组件和有状态组件的区别](https://segmentfault.com/a/1190000016774551)

```js
const head = (props) => {
  return;

  {
    props.name;
  }
};
```

#### mmutable.js

[为什么 react 要使用 immutable.js](https://www.jianshu.com/p/825b7b4c401d)

#### 生命周期函数

可查看[React 生命周期函数](/archives/202103112a3f29d/)

#### 高阶组件

[更快助你弄懂 React-高阶组件](https://segmentfault.com/a/1190000019834626)
[深入理解 React 高阶组件](https://www.jianshu.com/p/0aae7d4d9bc1)

#### setState

在 this.setState({})之后打印信息，会出现延迟，想要同步需要在 this.setState({},()=>{回调函数})，在回调函数中打印数据，可以同步

#### pureCompoent 和 compoent

[React 的 PureComponent Vs Component](https://www.jianshu.com/p/c41bbbc20e65)

#### hook 和 class 对比

[React Hook 与 Class 的一些对比](https://www.jianshu.com/p/b666ac2407b0)

#### redux

[Redux 入门教程（一）：基本用法](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)

##### 什么是 redux？

redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。
store 就是一个简单的 JavaScript 对象，而改变应用的 state 的唯一方式就是在应用用触发 action，
然后为这些 action 编写 reducers 来修改 state。
整个 state 的转化都是在 reducers 中完成的，并且不会有任何副作用

1. store 通过 reducer 创建了初始状态；
2. view 通过 store.getState()将 store 中保存的 state 挂载在了自己的状态上；
3. 用户产生了操作，调用了 actions 的方法；
4. actions 的方法被调用，创建了带有标示性信息的 action；
5. actions 将 action 通过调用 store.dispatch 方法发送到了 reducer 中；
6. reducer 接收到 action 并根据标识信息判断之后返回了新的 state；
7. store 的 state 被 reducer 更改为新 state 的时候，store.subscribe 方法里的回调函数会执行，此时就可以通知 view 去重新获取 state；

##### 在 redux 中，什么是 store？

- store 是一个 JavaScript 对象，它保存了整个应用的 state，于此同时，store 也承担了以下的职责：
  1. 允许通过 getState（）访问 state
  2. 通过 dispatch（action）改变 state
  3. 通过 subscribe（listener）注册 listeners
  4. 通过 subscribe（listener）返回函数处理 listener 的注册

##### 在 redux 中，什么是 action？

action 是一个纯 JavaScript 对象，他们必须有一个 type 属性表明正在执行 action 的类型。
实质上 action 是将数据从应用程序发送到 store 的有效载荷

##### 在 redux 中，什么是 reducer？

一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state

#### 什么是纯函数

一个纯函数是一个不依懒于且不改变其作用域之外的变量状态的函数，
这也意味着一个纯函数对于同样的参数总是返回同样的结果

#### Vue 和 React 的差别

1. react 是严格上针对 mvc 的 view 层，vue 则是 mvvm 模式
2. 操作 dom 的方式不同，vue 是通过指令操作 dom，而 react 通过 js 进行操作
3. 数据绑定不同，vue 实现的是双向绑定，而 react 是单向数据流
4. react 的 state 内容不可以直接修改，需要通过 setState 去修改，vue 的 state 不是必须的，数据主要有 data 属性在 vue 对象中管理的
5. React 是通过 JSX 渲染模板。而 Vue 是通过一种拓展的 HTML 语法进行渲染；
6. Vue 本质是 MVVM 框架，由 MVC 发展而来；React 是前端组件化框架，由后端组件化发展而来；

### 打包优化

#### npm 和 npx

https://www.nowcoder.com/ta/front-end

#### 重绘和重排

https://www.cnblogs.com/soyxiaobi/p/9963019.html

#### `__dirname` 路径名 `__filename` 文件名

如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。

```js
console.log(__filename);
// 打印: /Users/mjr/example.js
console.log(__dirname);
// 打印: /Users/mjr### 其他
```

## 参考资料

- [2021 前端必问面试题及答案](https://blog.csdn.net/weixin_42003850/article/details/108651427)
- [2021 前端面试经常被问到的题(附答案)](https://blog.csdn.net/xieanna123/article/details/105545758)
