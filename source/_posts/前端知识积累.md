---
title: 前端知识积累
abbrlink: 70ca98d5
date: 2021-02-15 14:59:30
tags:
  - 技术积累
  - 前端
  - 面试题
categories:
  - 技术积累
  - 前端
  - 面试题
toc: true
---

![首屏图](https://s3.ax1x.com/2021/02/22/y7Le4x.jpg)

<!-- more -->

## web前端面试题

### HTML5

### CSS3

### JS

#### 原型链和继承

![原型链](https://s3.ax1x.com/2021/03/06/6nomVK.png)

##### 原型链

js对象独有的__proto__属性，当访问一个对象的属性时，如果该对象内不存在这个属性，会去它的__proto__属性所指向的那个对象（父对象）里找，直到null

##### proto

对象都有私有属性__proto__（），从对象指向实例原型

##### prototype

函数独有的属性，从一个函数指向一个对象，包含所有实例可共享的属性和方法，任何函数创建时，会默认创建该函数的prototype对象

##### constructor

实例的构造函数（constructor）属性，指向实例

##### 总结

所有函数和对象最终都是由Function构造函数得来，所以constructor属性的终点就是Function这个函数。

1. prototype指向的原型对象又有一个属性constructor，这个属性也是一个指针，指回原构造函数，即这个方法。
2. __proto__和constructor属性是对象所独有的，prototype属性是函数所独有的。
3. JS中函数也是一种对象，所以函数也拥有__proto__和constructor属性
4. 为什么有prototype，如果没有，每次新建对象都会继承构造函数的所有属性，方法，浪费性能，用了prototype后，属性每个对象的值相同性不高，写在构造函数里，而方法通常是通用的，使用prototype可以让每个对象共享同一个方法，而不用每次都copy一个，而且能实时更新
5. [JavaScript原型链和继承](https://www.cnblogs.com/tylerdonet/p/9595436.html)
6. [为什么使用prototype](https://segmentfault.com/a/1190000000653327)

#### 浅拷贝和深拷贝

* 基本数据类型：名字和值都存在栈中
* 引用数据类型：名字在栈中，值在堆中，栈内存会提供一个引用地址，指向堆内存中的值
* 浅拷贝：
  * for只遍历第一层
  * assign
  * `=`直接赋值
* 深拷贝：
  * 递归遍历所有层级
  * 利用JSON对象【JSON.stringfy() JSON.parse()】
  * 通过jQuery的extend方法实现深拷贝
  * lodash函数库实现深拷贝
  * 用slice实现对数组的深拷贝,slice() 方法可从已有的数组中返回选定的元素。
  * 使用扩展运算符实现深拷贝
  * 如对象的value是基本类型，可以用Object.assign来实现深拷贝，但是要把它赋值给一个空对象assign第一层是深拷贝，第二层以后是浅拷贝
  * Reflect法
  * 用concat实现对数组的深拷贝
  * 直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。
  * 手动实现深拷贝

```js
// JSON对象进行深拷贝
function deepClone2(obj) {
  var _obj = JSON.stringify(obj),
    objClone = JSON.parse(_obj);
  return objClone;
} // 无法实现对对象中 方法 的深拷贝，会显示为undefined

// jQuery的extend方法进行深拷贝
var array = [1,2,3,4];
var newArray = $.extend(true,[],array); // true为深拷贝，false为浅拷贝

// lodash方法进行深拷贝
let result = _.cloneDeep(test)
```

#### js中的堆和栈

* 栈（stack）：简单地数据段，存放在栈中，有固定大小的内存（自动分配），自动释放
  * 基本数据类型：number，string，boolean，undefined，null
  * 栈存储了什么：变量名，基本数据类型值，地址
  * 全局作用域，私有作用域，都属是栈内存，理论上，存储的越少，运行速度越快
  * 先进后出
  * 栈内存回收：作用域销毁（立即销毁，不销毁，不立即销毁）
    * 全局作用域销毁：一般情况不销毁，页面关闭，整个作用域销毁
    * 私有作用域销毁 ：
      * 不销毁
      * 销毁
      * 不立即销毁
* 堆（heap）：动态分配内存，大小不定也不会自动释放
  * 引用类型：栈中存放地址，指向堆中的对象，当我们要获取（函数，数组，对象等）的时候，先从栈中获取地址，然后从堆中获取数据
  * 先进先出
  * 堆存储了什么：引用数据类型的值
  * 内存回收：GC垃圾回收机制
    * chrome：标记法，每隔一段时间对所有的空间地址检测，如果没有被占用，立即回收
    * ie和火狐：计数法，空间地址被占用一次+1，空闲一次空间地址-1，如果为0 被回收

[10分钟了解JS堆、栈以及事件循环的概念](https://juejin.cn/post/6844903618999500808)

#### 闭包

* 闭包函数：声明在一个函数中的函数，叫做闭包函数。
* 闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
* 参数和变量不会被垃圾回收机制回收

```js
function a() {
    var name = 'Shier'
    return function(){
        return name
    }
}
var b = a()
console.log(b())
// 通过返回函数中返回的内部变量，使函数外部能够使用和访问函数内部变量
```

#### setTimeout

setTimeout有两个参数，第一个参数为一个函数，我们通过该函数定义将要执行的操作。第二个参数为一个时间毫秒数，表示延迟执行的时间。

```js
var timer = setTimeout(function() {
    console.log('如果不清除我，我将会一秒之后出现。');
}, 1000)

clearTimeout(timer);  // 清除之后，通过setTimeout定义的操作并不会执行

for (var i=1; i<=5; i++) { 
    setTimeout( function timer() {
        console.log(i);
    }, i*1000 );
}
// 上述结果返回总为6
// 循环被立即执行，定时器依次放入执行队列中，
// 并分别等待1、2、3、4、5s执行console，
// 在定时器输出的时候，i已经自增完毕，因此输出的均为6

for (var i=1; i<=5; i++) { 
    (function(i) {
        setTimeout( (function timer() { // 或者在这里使用闭包
            console.log(i);
        })(i), i*1000 );
    })(i)
}
// 使用闭包将值存住，输出为123456
```

console的返回值中，会有两行，一行是一个唯一的id，其他的是输出的内容
每个setTimeout在执行时，会返回一个唯一ID。在使用时，常常会使用一个变量将这个唯一ID保存起来，用以传入clearTimeout，清除定时器。

#### 事件委托

* DOM事件流：事件捕获，目标阶段，事件冒泡
addEventListener（‘click’，function(event){触发事件}, false）默认在事件冒泡阶段触发，默认值false
* 事件委托：
事件委托利用了事件冒泡和event.target，当有一系列子元素都需要绑定事件时，只需要将事件绑定在父元素即可
  * event.currentTarget:事件绑定的元素（绑定在父级元素）
  * event.target:触发事件的源头（所点击的子元素）
  * target：事件目标

#### this指向，call/apply/bind，回调函数

1. 一般函数,this指向全局对象window;
1. 在严格模式下"use strict",为undefined.
1. 对象的方法里调用,this指向调用该方法的对象. 【this指的是，调用函数的那个对象】
1. 构造函数里的this,指向创建出来的实例.

* call，apply，bind，改变函数运行时的指向，当第一个参数为null或undefind时，指向window
  * call：传入参数列表，改变函数指向并立即调用，第一个参数同apply，第二个参数必须是单个参数列表，不能是数组
  * apply：可以传入数组，第一个参数：要绑定给this的值 第二个参数：参数列表（可以是数组）
  * bind：改变this指向后，返回的是函数

例子1：

```js
var obj = {
    name: 'Dot'
}
function printName() {
    console.log(this.name)
}
var dot = printName.bind(obj)
console.log(dot) // function () { … }
dot()  // Dot
//bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。
//而原函数 printName 中的 this 并没有被改变，依旧指向全局对象 window。
```

例子2：

```js
var a = 1
var obj1 = {
    a:2,
    fn:function(){
    console.log(this.a)
    }
}
obj1.fn()   //2    
//此时的this是指obj1这个对象，obj1.fn()
//实际上是obj1.fn.call(obj1)，事实上谁调用这个函数，this就是谁
```

例子3：点击页面，依次输出：document和window对象
解析：点击页面监听click事件属于方法调用，this指向事件源DOM对象，即obj.fn.apply(obj)，setTimeout内的函数属于回调函数，可以这么理解f1.call(null,f2)，所以this指向window。

```js
document.addEventListener('click', function(e){
    console.log(this);
    setTimeout(function(){
        console.log(this);
    }, 200);
}, false);
```

#### 数组的常用操作

* concat()
  * 拼接数组：连接两个或更多的数组，并返回结果。
* join()
  * 按字符拼接字符串：把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。
* splice()
  * 替换元素：删除元素，并向数组添加新元素。
* slice()
  * 截取数组：从某个已有的数组返回选定的元素
* pop()
  * 删除最后一个：删除并返回数组的最后一个元素(改变原数组)
* push()
  * 拼接元素：向数组的末尾添加一个或更多元素，并返回新的长度。
* shift()
  * 删除第一个：删除并返回数组的第一个元素
* unshift()
  * 压入元素：向数组的开头添加一个或更多元素，并返回新的长度。
* reverse()
  * 数组翻转：颠倒数组中元素的顺序。
* sort()
  * 数组排序：对数组的元素进行排序
* toString()
  * 数组转换字符串：把数组转换为字符串，并返回结果。
* valueOf()
  * 返回数组对象的原始值。
* toSource()
  * 返回该对象的源代码。
* toLocaleString()
  * 根据本地时间把Date对象转换为字符串。

#### set和weakset，map和weakmap

#### let和const

#### 解构赋值

#### typeof原理

#### 0.1+0.2 === 0.3吗，为什么

#### 前端安全 xss 和 csrf

#### 说明BFC及其使用

#### js基本数据类型

#### 循环

#### Js数组都有哪些方法及其作用、用法、返回值？详细说了一下splice()

#### Js数组去重

#### 说明冒泡排序、插入排序实现的思想、步骤、每趟的结果等

#### 什么是二分查找

#### HTTP协议相关

##### 请求头

##### 响应头

##### 状态码（5大类）

##### 报文格式

##### 一次http完整的过程

##### 详细说一下Accept - Encoding的作用，和性能有关系？

##### http有哪些请求方式？

##### Get和post的区别？

#### Ajax相关

##### 如何实现

##### 用jQuery实现一个ajax

##### 有没有看过jQuery内部是如何实现的？

##### 说说链式调用

#### Application相关

##### 什么是Cookie和Session？

##### Cookie和Session他们的区别？

##### Js实现cookie和session两者有联系吗？

##### localStorage、sessionStorage、cookie是什么？

#### 垂直居中布局 4中

#### 浮动引起的问题，如何清除浮动【4种

#### postion和z-index的关系？

#### DOM操作：获取、增、删、查、改等操作

#### JS交换两个节点如何实现？

#### tcp三次握手四次挥手

#### ES6有哪些新特性

* let，const
* 箭头函数
* 解构赋值
* set、weakSet、map、weakMap
* proxy
* generator
* reflect
* async、await
* class
* promise

#### 如何设置一个元素不可见 4中

#### 什么是跨域问题，有哪些跨域方式

#### JS 异步解决方案的发展历程以及优缺点

#### 行内元素和块元素区别，image 标签属于哪种

#### eval

#### Object.assign()

#### reduce 求和

#### 普通函数和构造函数

### http

### ES6

### Vue

### React

#### 有状态组件和无状态组件

性能更高，因为他就是一个函数
由于是无状态组件，所以，无论props会否变更，都会重新刷新这个组件

[简述React中无状态组件和有状态组件的区别](https://segmentfault.com/a/1190000016774551)

```js
const head = (props) => {
return

{props.name}

}
```

#### mmutable.js

[为什么 react要使用immutable.js](https://www.jianshu.com/p/825b7b4c401d)

#### 生命周期函数

可查看[React生命周期函数](/archives/202103112a3f29d/)

#### 高阶组件

[更快助你弄懂React-高阶组件](https://segmentfault.com/a/1190000019834626)
[深入理解 React 高阶组件](https://www.jianshu.com/p/0aae7d4d9bc1)

#### setState

在this.setState({})之后打印信息，会出现延迟，想要同步需要在this.setState({},()=>{回调函数})，在回调函数中打印数据，可以同步

#### pureCompoent 和 compoent

[React 的 PureComponent Vs Component](https://www.jianshu.com/p/c41bbbc20e65)

#### hook和class对比

[React Hook 与Class的一些对比](https://www.jianshu.com/p/b666ac2407b0)

#### redux

[Redux 入门教程（一）：基本用法](http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html)

### 打包优化

#### npm和npx

https://www.nowcoder.com/ta/front-end

#### 重绘和重排

https://www.cnblogs.com/soyxiaobi/p/9963019.html

#### `__dirname` 路径名 `__filename` 文件名

如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。

```js
console.log(__filename);
// 打印: /Users/mjr/example.js
console.log(__dirname);
// 打印: /Users/mjr### 其他
```

## 参考资料

* [2021前端必问面试题及答案](https://blog.csdn.net/weixin_42003850/article/details/108651427)
* [2021前端面试经常被问到的题(附答案)](https://blog.csdn.net/xieanna123/article/details/105545758)

* concat()  拼接数组
* join()    转换字符串
* splice()  替换
* slice()   截取
* pop()     删除末尾
* push()    拼接末尾
* shift()   删除首个
* unshift() 压入首位
* reverse() 翻转
* sort()    排序
* toSource()
* toString()转换字符串
* toLocaleString()转换本地数组
* valueOf()
