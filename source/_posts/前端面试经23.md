---
title: 前端面试经23
abbrlink: b5b74555
date: 2022-03-30 14:56:56
tags:
  - 技术积累
  - 前端
  - 面试题
categories:
  - 技术积累
  - 前端
  - 面试题
toc: true
---

![首屏图](https://s1.ax1x.com/2022/06/06/Xwo0Mt.jpg)

<!-- more -->

## 前端面试汇总

### 自我介绍

#### 最近的工作经历及项目经验，用到了哪些技术，负责哪些工作

- React
  - hook
    - useState 是一个 React Hook，它允许你向组件添加一个状态变量。
    - useEffect 是一个 React Hook，它允许你将组件与外部系统同步。
      - 第二个可选参数为 [] 时初始化获取数据
      - 第二个可选参数为 一个 或 多个值 时，监听这些值的变化而进行操作
      - 使用 return 的清除机制 [文档传送门](https://zh-hans.legacy.reactjs.org/docs/hooks-effect.html)
    - useRef 是一个 React Hook，它能帮助引用一个不需要渲染的值
      - useRef 用于操作 DOM 元素 `useRef().current.reload()` [文档传送门](https://zhuanlan.zhihu.com/p/609933594)
    - useMemo 是一个 React Hook，它在每次重新渲染的时候能够缓存计算的结果。
- Antd
  - pro-components
  - pro-table
  - pro-card
- single-spa
- charts
  - cloud-charts
  - echarts
- formilyjs
- classNames 一个简单的支持动态多类名的工具库
- eventemitter2 组件间进行事件的监听与传递
- 协同开发
  - 墨刀 在线原型
  - codesign 在线设计稿
  - Yapi 后端代码联调
  - 禅道/JIRA 开发任务拆分管理
  - Jenkins CI/CD
- tailwindcss['teilˌwind] 它是一个 CSS 样式库，为我们提供了构建定制设计而无需使用自定义样式所需的所有构建块

#### 遇到了什么问题及怎么处理的

- 优化问题
  - 数据大屏仿 PPT 横向切换 react-transition-group
    - 使用 location 承接 trend 标记滚动方向
    - 使用 CSSTransition 实现横向滚动特效
    - 横屏切换加载时添加 load 效果，避免白屏
- 兼容问题
  - 九宫格动效低版本浏览器效果差异
- 菜单定制化需求
  - 委员会管理的树形菜单与联动
  - 根节点重复
- formilyjs 复杂场景
  - 数据联动
  - 数据字典获取
    - window.\_\_globalData
    - window.\_\_globalData.currentUser
  - 数据异步获取
    - await window.\_\_api.func()
  - 表单的动态生成

### CSS 相关

#### BFC 简单介绍，什么是 BFC，如何创建 BFC，BFC 的特性有什么。BFC 上下两个相邻的容器有什么特点

什么是 BFC(块级格式化上下文)：Block Formatting Context，解释为块级格式化上下文

创建方式：

1. display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex
2. overflow 的值不是 visible（overflow:hidden、overflow:scroll）
3. float 的值不是 none。（float:left 或者 float:right）
4. position 的值不是 static 或者 relative。（position:absolute 或者 position:fixed）
5. 父元素与正常文件流的子元素（非浮动子元素）自动形成一个 BFC

特性：

1. 父亲管儿子(子元素浮动，父元素不再塌陷)
2. 兄弟之间划清界限(兄弟元素其一浮动重叠，另一个元素设置 BFC 便不再重叠)

### JS 相关

#### null 与 undefined 的区别

null 表示没有对象，即该处不应该有值。
典型用法是:作为函数的参数，表示该函数的参数不是对象。作为对象原型链的终点。

undefined 表示缺少值，就是此处应该有一个值，但是还没有定义。
典型用法是:变量被声明了，但没有赋值时，就等于 undefined。

#### typeOf 判断 null 的时候是 object 还是一个普通数据类型

可参考 [检测变量的类型并区分数组和对象](https://www.gaotianyang.top/archives/2021032932cd20c6/#检测变量的类型并区分数组和对象)

| 值               | 类型        |
| ---------------- | ----------- |
| typeof 1         | "number"    |
| typeof NaN       | "number"    |
| typeof "1"       | "string"    |
| typeof true      | "boolean"   |
| typeof undefined | "undefined" |
| typeof null      | "object"    |
| typeof []        | "object"    |
| typeof {}        | "object"    |

- 如果返回 number，判断是否是 NAN，isNaN(a) ，
- 首先使用 typeof 判断，如果返回 object，判断是否为 null
- 判断数组 or 对象
  - 最后使用 toString 如果是"[object Object]”是对象，否则是数组。
  - 最后使用 `[] instanceof Array` `{} instanceof Array`如果是 false 是对象，否则是数组。

为什么 null 的类型判断是 Object 呢？

| 数据类型     | 机器码标识      |
| ------------ | --------------- |
| 对象(Object) | 000             |
| 整数         | 1               |
| 浮点数       | 010             |
| 字符串       | 100             |
| 布尔         | 110             |
| undefined    | -2^31(即全为 1) |
| null         | 全为 0          |

在判断数据类型时，是根据机器码低位标识来判断的，而 null 的机器码标识为全 0，而对象的机器码低位标识为 000。所以 typeof null 的结果被误判为 Object。

[为什么 typeof null 的结果是 Object?](https://juejin.cn/post/6844903895177805837)

#### 扩展运算符是深拷贝还是浅拷贝

> 元素是简单类型是深拷贝，元素是引用类型是浅拷贝

如果只是一层数组或是对象，其元素只是简单类型的元素，那么属于深拷贝 (就是一层拷贝，暂时就理解为深拷贝吧! ! ! ! )

```js
let aa = {
  age: 18,
  name: 'aaa'
};

let bb = [...aa];
bb.age = 22;

console.log(aa.age); // 18
```

如果数组或对象中的元素是引用类型的元素，那么就是浅拷贝

```js
let aa = {
  age: 18,
  name: 'aaa',
  address: {
    city: 'shanghai'
  }
};

let bb = [...aa];
bb.address.city = 'shenzhen';
console.log(aa.address.city); // shenzhen;
```

如何使得深拷贝

```js
let aa = {
  age: 18,
  name: 'aaa',
  address: {
    city: 'shanghai'
  }
};

let bb = {
  ...aa,
  address: { ...aa.address }
};

bb.address.city = 'shenzhen';
console.log(aa.address.city); // shanghai
```

或者利用 JSON.parse(JSON.stringfy(xxx))来实现深拷贝
注意: JSON.parse(JSON.stringfy(xxx))的方法，如果变量中含有 Promise 对象，则不可以使用该方法

[第一层深拷贝第二层浅拷贝](https://blog.csdn.net/weixin_43925630/article/details/111299038)

#### 箭头函数和普通函数的区别

1. 语法更加简洁、清晰
2. 箭头函数不会创建自己的 this（重要！！深入理解！！）
3. 箭头函数继承而来的 this 指向永远不变
4. .call()/.apply()/.bind()无法改变箭头函数中 this 的指向
5. 箭头函数不能作为构造函数使用
6. 箭头函数没有自己的 arguments
7. 箭头函数没有原型 prototype
8. 箭头函数不能用作 Generator 函数，不能使用 yeild 关键字

#### 箭头函数为什么不能当做构造函数

- 从上面的运行结果也可以看到箭头函数与构造函数相比，缺少了很多东西，比如：caller，arguments，prototype，但同时也可以看到，箭头函数是有**proto**属性的，所以箭头函数本身是存在原型链的，他也是有自己的构造函数的，但是原型链到箭头函数这一环就停止了，因为它自己没有 prototype 属性，没法让他的实例的**proto**属性指向，所以箭头函数也就无法作为构造函数。
- 同时我们可以看到，由于箭头函数没有自己的 this 指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数，不能绑定 this，所以 call()和 apply()的第一个参数会被忽略。

可参考[箭头函数能作为构造函数吗](https://www.gaotianyang.top/archives/2021032932cd20c6/#箭头函数能作为构造函数吗)

#### new 的执行过程是怎样的

1. 创建一个新对象
2. 将新对象的*proto*指向构造函数的 prototype 对象
3. 将构造函数的作用域赋值给新对象 （也就是 this 指向新对象）
4. 执行构造函数中的代码（为这个新对象添加属性）
5. 返回新的对象

```js
var Obj = {};
Obj._proto_ = Person.prototype();
Person.call(Obj);
```

可参考[New 关键词干了什么](https://www.gaotianyang.top/archives/2021032932cd20c6/#New关键词干了什么)

#### new 操作符实例化对象时 构造函数有返回值(字符串)会怎么样

> 正常将对象实例化

当构造函数返回了函数或非 null 对象时(func、[]、{})
执行 var x = new X()，此时只是将 X 作为普通的函数执行，
函数执行的返回值直接作为变量 x 的值，变量 x 不是类 X 的实例化对象，X.prototype 也不是变量 x 的原型。

其他情况（构造函数无返回值、返回值不是对象也不是函数、返回值是 null），正常将对象实例化。

[JavaScript 中使用 new 操作符实例化对象时构造函数有返回值的情况分析](https://blog.csdn.net/iispring/article/details/105108178)

#### class 和 function 的区别

相同点：

都可以成为构造函数

不同点：

- class 构造函数必须使用 new 操作符
- class 声明不可以提升
- class 不可以用 call、apply、bind 改变执行上下文

[JavaScript class 和 function 的区别](https://blog.csdn.net/Jack_lzx/article/details/121098261)
[JavaScript ES6-class 和 ES5-构造函数 function 的区别](https://zhuanlan.zhihu.com/p/657235691)

#### class 里存在 this 吗

有 this 但是不可以通过 .call 的方式进行指向

### 浏览器相关

#### 浏览器解析流程

1. DNS 域名解析
2. 发起 TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回响应结果
5. 浏览器解析渲染页面
6. 断开连接

可参考[输入地址后的过程](https://www.gaotianyang.top/archives/2021032932cd20c6/#输入地址后的过程)

#### DNS 域名解析有哪些操作

1. 查看浏览器缓存
2. 查看系统缓存
3. 查看路由器缓存
4. 查看 ISP DNS 缓存
5. 询问根域名服务器
6. 询问顶级域名服务器
7. 询问权威域名（主域名）服务器
8. 保存结果至缓存

[一文读懂 DNS 原理及解析过程](https://www.sfn.cn/news/technology/detail/222.html?navId=22)

#### TCP 链接过程 3 次握手 4 次挥手

[一文搞懂 TCP 的三次握手和四次挥手](https://bbs.huaweicloud.com/blogs/233667)

#### 请求如果阻塞要如何处理

[前端请求队列，解决多个请求同时请求一个接口导致阻塞的问题](https://blog.csdn.net/qq_34337333/article/details/131239848)

#### 是否了解 UDP(用户数据报协议)协议

UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。当强调传输性能而不是传输的完整性时适合使用此种协议.

[UDP 协议](https://baike.baidu.com/item/UDP/571511?fr=ge_ala)

#### 浏览器如何渲染 html

1. 解析 HTML 生成 DOM 树。
2. 解析 CSS 生成 CSSOM 规则树。
3. 将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。
4. 遍历渲染树开始布局，计算每个节点的位置大小信息。
5. 将渲染树每个节点绘制到屏幕。

[浏览器渲染过程](https://www.gaotianyang.top/archives/2021032932cd20c6/#浏览器渲染过程)

#### 有哪些因素会阻塞浏览器渲染

白屏时间的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript； 所以要想缩短白屏时长，可以有以下策略：

1. 内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了，但并不是所有的场合都适合内联。
2. 尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
3. 将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
4. 利用媒体查询属性，在特定的场景下加载特定的 CSS 文件。

[漫漫前端路之浏览器基础——页面渲染阻塞原因分析篇](https://juejin.cn/post/7083752157085696014)

#### CDN 的原理是什么

CDN 的原理是: 基于分布式架构，通过将源服务器上的内容分发到多个节点服务器上，使用户能够从最近的服务器中获取所需内容。
这些节点服务器被称为 边缘服务器，它们通常位于不同的地理位置，并通过高速互联网连接互相交换数据。
用户通过接入离他们最近的 边缘服务器 来获取所需的内容，从而降低了响应时间和延迟，提高了网站的访问速度。

[CDN 原理入门，你学会了吗？](https://www.51cto.com/article/750758.html)

### react 相关

#### React 函数组件和类组件的区别

1. 语法上
2. ~~状态管理~~ 使用 hooks 解决
3. ~~生命周期钩子~~ 使用 hooks 解决
4. 调用方式
5. 获取渲染时的值

- 语法上

函数组件是一个纯函数，它接收一个 `props` 对象返回一个 `react` 元素；
类组件需要去继承 `React.Component` 并且创建 `render` 函数返回 `react` 元素，虽然实现的效果相同，但需要更多的代码。

- ~~状态管理~~

因为函数组件是一个纯函数，所以不能在组件中使用 `setState()`，这也是为什么把函数组件称作为无状态组件。
如果要在组件中使用 `state` ，可以选择创建一个类组件或者将 `state` 提升到你的父组件中，然后通过 `props` 对象传递到子组件。

> 注意：在 `react16.8` 版本中添加了 `hooks` ，使得我们可以在函数组件中使用 `useState` 钩子去管理 `state` ，使用 `useEffect` 钩子去使用生命周期函数。
> 因此，2、3 两点就不是它们的区别点。而从这个改版中我们也可以看出 React 团队更看重函数组件，而且曾提及到在 `react` 之后的版本将会对函数组件的性能方面进行提升。

- ~~生命周期钩子~~

函数组件中不能使用生命周期钩子，原因和不能使用 `state` 一样，所有的生命周期钩子都来自于继承的 `React.Component` 中。
因此，如果要使用生命周期钩子，就需要使用类组件。

> 注意：在 `react16.8` 版本中添加了 `hooks` ，使得我们可以在函数组件中使用 `useState` 钩子去管理 `state` ，使用 `useEffect` 钩子去使用生命周期函数。
> 因此，2、3 两点就不是它们的区别点。而从这个改版中我们也可以看出 React 团队更看重函数组件，而且曾提及到在 `react` 之后的版本将会对函数组件的性能方面进行提升。

- 调用方式

如果 `SayHi` 是一个函数， `React` 需要调用它：

```js
// 你的代码
function SayHi() {
  return <p>Hello, React</p>;
}
// React 内部
const result = SayHi(props); // » <p>Hello, React</p>
```

如果 `SayHi` 是一个类， `React` 需要先用 `new` 操作符将其实例化，然后调用刚才生成实例的 `render` 方法：

```js
// 你的代码
class SayHi extends React.Component {
  render() {
    return <p>Hello, React</p>;
  }
}
// React 内部
const instance = new SayHi(props); // » SayHi {}
const result = instance.render(); // » <p>Hello, React</p>
```

可想而知，函数组件重新渲染将重新调用组件方法返回新的 `react` 元素，类组件重新渲染将 `new` 一个新的组件实例，
然后调用 `render` 类方法返回 `react` 元素，这也说明为什么类组件中 `this` 是可变的。

- 获取渲染时的值

考虑以下组件：

```js
function ProfilePage(props) {
  const showMessage = () => {
    alert('Followed ' + props.user);
  };

  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };

  return <button onClick={handleClick}>Follow</button>;
}
```

`UserProfile` 组件很简单，就一个 `Follow` 按钮，该按钮使用了 `setTimeout` 模拟网络请求。
用户点击这个按钮之后会弹出一个警告框。如果 `props.user` 为 `'Dan'`，它将在三秒钟后显示 `'Followed Dan'`。

我们如何将其编写为类？天真的翻译可能像这样：

```js
class ProfilePage extends React.Component {
  showMessage() {
    alert('Followed ' + this.props.user);
  }

  handleClick() {
    setTimeout(this.showMessage.bind(this), 3000);
  }

  render() {
    return <button onClick={this.handleClick.bind(this)}>Follow</button>;
  }
}
```

通常认为这两个代码段是等效的。人们经常在这些模式之间自由重构，而没有注意到它们的含义

但是，这两个代码段是完全不同的。

分别按下面的顺序来操作 Follow 按钮：

1. 先点击 Follow 按钮
2. 在 3s 之前更改下拉选择项的选项
3. 阅读弹出的警告框内容

这就发现函数组件和类组件是有区别的：

- 函数组件：按上面所列的三个步骤操作时，当用户在 3s 前更改下拉选择框的选项时，h1 的用户名会立马改变，而 3s 后弹出的警告框中的用户名并不会改变
- 类组件：按上面所列的三个步骤操作时，当用户在 3s 前更改下拉选择框的选项时，h1 中的用户名会立马改变，而 3s 后弹出的警告框中的用户名也会改变

我们可以在类的构造函数中绑定这些方法：

```js
class ProfilePage extends React.Component {
  render() {
    // 获取 props
    cosnt props = this.props

    // 它们不是类方法
    const showMessage = () => {
        alert('Followed ' + props.user);
    }

    const handleClick = () => {
        setTimeout(showMessage, 3000)
    }

    return <button onClick={handleClick}>Follow</button>
  }
}
```

这样一来，函数组件和类组件所达到的效果都一样了。在类组件中可以捕获渲染时的 props。效果上看上去是一样了，但看起来怪怪的。如果在类组件中的 render 中定义函数而不是使用类方法，那么还有使用类的必要性？

[React 函数组件和类组件的区别](https://cloud.tencent.com/developer/article/1843744)

#### Usememo 是否了解，原理是什么

- useMemo 是用来缓存计算属性的，它会在发现依赖未发生改变的情况下返回旧的计算属性值的地址。
- useMemo 绝不是用的越多越好，缓存这项技术本身也需要成本。
- useMemo 的使用场景之一是:只需要给拥有巨大计算量的计算属性缓存即可。
- useMemo 的另一个使用场景是：当有计算属性被传入子组件，并且子组件使用了 react.memo 进行了缓存的时候,为了避免子组件不必要的渲染时使用

[React 性能优化篇之 useMemo 的使用场景及其深度解读](https://juejin.cn/post/7108278900085489671)

#### 为什么使用 hooks

1. 更容易复用代码
2. 清爽的代码风格+代码量更少
3. 代码可读性更强
4. 组件树层级变浅
5. 不用再去考虑 this 的指向问题

[为什么要使用 Hooks？](https://zhuanlan.zhihu.com/p/392191865)

#### usestate 赋值操作是同步的还是异步的，多次赋值，界面会渲染几次

严格来说，不是异步也不是同步。setState 有时候不会即时更新是因为 React 的优化机制，在事件处理器中批量处理更新。
而在某些时候，setState 会同步更新。分别看一下这两种情况。

```js
const onClick = () => {
  this.setState({ a: 1 });
  this.setState({ a: 2 });
};
```

组件只会更新一次

而在异步代码（promise、async/await、setTimeout/setInterval、fetch）中的更新，不会批量处理， 比如:

```js
const onClick = () => {
  callAPI().then(() => {
    this.setState({ a: 1 });
    this.setState({ a: 2 });
  });
};
```

组件会更新两次，我们称这样的更新是 outside of react event handlers,
发生在 react 事件处理器之外，此时的回调在 react 执行机制完成之后进行，react 没办法批量更新。

[关于 useState 你需要知道的一切](https://juejin.cn/post/6997020924205596702)

#### 为什么虚拟 dom 优于操作真实 dom

- 虚拟 DOM 不一定会比操作原生 DOM 更快。
- 虚拟 DOM 的优势在于节点进行改动的时候尽量减少开销
- React 从来没说过虚拟 DOM 会比原生更快。
- 框架的本质是提升开发效率，让我们的注意力更集中于数据

[使用虚拟 DOM 一定会比直接操作真实 DOM 快吗？这还真不一定。](https://juejin.cn/post/7130538545063657486)

#### 是否了解 react 的优化算法，是如何优化的

1. Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。
2. 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。
3. 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。

[「React 深入」一文吃透虚拟 DOM 和 diff 算法](https://juejin.cn/post/7116326409961734152)

### 项目相关

#### 全面质量管理系统

- 九宫格 card 动效 低版本浏览器兼容性 图片替代 css 效果
- 大屏横向切换 渐进渐出 白屏处理
- 使用 cloud-charts 展示图表信息
- 使用 formilyjs 渲染表单 快速搭建页面 动态生成页面 复杂场景需求 联动、全局字典
- 组织架构 菜单与组织架构树状图联动效果
- 使用了 single-spa 微服务项目架构 各个子应用间的相互引用 在基座上挂载子应用

#### 如何进行的各个子应用相互间引用

useHistory()、useLocation()需要从外层使用应用获取并传递至引用的应用

#### 各个子应用之间的 css 样式污染

1. 设置 ElConfigProvider
2. 设置 SCSS 和 CSS 变量
3. 定义子应用的 class 包裹

[微前端基座样式，污染子应用样式的解决方案](https://juejin.cn/post/7114882453956722724)
